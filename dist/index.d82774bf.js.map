{"mappings":"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","sources":["node_modules/@splidejs/splide-extension-video/node_modules/@splidejs/splide/dist/js/splide.esm.js","node_modules/@splidejs/splide-extension-video/node_modules/@splidejs/splide/dist/js/utils/splide-utils.esm.js","node_modules/@splidejs/splide-extension-video/src/js/constants/classes.ts","node_modules/@splidejs/splide-extension-video/src/js/constants/defaults.ts","node_modules/@splidejs/splide-extension-video/src/js/constants/events.ts","node_modules/@splidejs/splide-extension-video/src/js/classes/AbstractVideoPlayer.ts","node_modules/@splidejs/splide-extension-video/src/js/constants/states.ts","node_modules/@splidejs/splide-extension-video/src/js/players/html/HTMLVideoPlayer.ts","node_modules/@splidejs/splide-extension-video/node_modules/@vimeo/player/dist/player.es.js","node_modules/@splidejs/splide-extension-video/src/js/players/vimeo/VimeoPlayer.ts","node_modules/@splidejs/splide-extension-video/src/js/players/youtube/YouTubeIframeAPILoader.ts","node_modules/@splidejs/splide-extension-video/src/js/players/youtube/YouTubePlayer.ts","node_modules/@splidejs/splide-extension-video/src/js/constants/i18n.ts","node_modules/@splidejs/splide-extension-video/src/js/classes/PlayerUI.ts","node_modules/@splidejs/splide-extension-video/src/js/classes/Player.ts","node_modules/@splidejs/splide-extension-video/src/js/constants/data-attributes.ts","node_modules/@splidejs/splide-extension-video/src/js/build/default.ts","node_modules/@splidejs/splide-extension-video/src/js/extensions/Video/Video.ts"],"sourcesContent":["function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/*!\n * Splide.js\n * Version  : 4.0.8\n * License  : MIT\n * Copyright: 2022 Naotoshi Fujita\n */\nvar MEDIA_PREFERS_REDUCED_MOTION = \"(prefers-reduced-motion: reduce)\";\nvar CREATED = 1;\nvar MOUNTED = 2;\nvar IDLE = 3;\nvar MOVING = 4;\nvar SCROLLING = 5;\nvar DRAGGING = 6;\nvar DESTROYED = 7;\nvar STATES = {\n  CREATED: CREATED,\n  MOUNTED: MOUNTED,\n  IDLE: IDLE,\n  MOVING: MOVING,\n  SCROLLING: SCROLLING,\n  DRAGGING: DRAGGING,\n  DESTROYED: DESTROYED\n};\n\nfunction empty(array) {\n  array.length = 0;\n}\n\nfunction slice(arrayLike, start, end) {\n  return Array.prototype.slice.call(arrayLike, start, end);\n}\n\nfunction apply(func) {\n  return func.bind.apply(func, [null].concat(slice(arguments, 1)));\n}\n\nvar nextTick = setTimeout;\n\nvar noop = function noop() {};\n\nfunction raf(func) {\n  return requestAnimationFrame(func);\n}\n\nfunction typeOf(type, subject) {\n  return typeof subject === type;\n}\n\nfunction isObject(subject) {\n  return !isNull(subject) && typeOf(\"object\", subject);\n}\n\nvar isArray = Array.isArray;\nvar isFunction = apply(typeOf, \"function\");\nvar isString = apply(typeOf, \"string\");\nvar isUndefined = apply(typeOf, \"undefined\");\n\nfunction isNull(subject) {\n  return subject === null;\n}\n\nfunction isHTMLElement(subject) {\n  return subject instanceof HTMLElement;\n}\n\nfunction toArray(value) {\n  return isArray(value) ? value : [value];\n}\n\nfunction forEach(values, iteratee) {\n  toArray(values).forEach(iteratee);\n}\n\nfunction includes(array, value) {\n  return array.indexOf(value) > -1;\n}\n\nfunction push(array, items) {\n  array.push.apply(array, toArray(items));\n  return array;\n}\n\nfunction toggleClass(elm, classes, add) {\n  if (elm) {\n    forEach(classes, function (name) {\n      if (name) {\n        elm.classList[add ? \"add\" : \"remove\"](name);\n      }\n    });\n  }\n}\n\nfunction addClass(elm, classes) {\n  toggleClass(elm, isString(classes) ? classes.split(\" \") : classes, true);\n}\n\nfunction append(parent, children) {\n  forEach(children, parent.appendChild.bind(parent));\n}\n\nfunction before(nodes, ref) {\n  forEach(nodes, function (node) {\n    var parent = (ref || node).parentNode;\n\n    if (parent) {\n      parent.insertBefore(node, ref);\n    }\n  });\n}\n\nfunction matches(elm, selector) {\n  return isHTMLElement(elm) && (elm[\"msMatchesSelector\"] || elm.matches).call(elm, selector);\n}\n\nfunction children(parent, selector) {\n  var children2 = parent ? slice(parent.children) : [];\n  return selector ? children2.filter(function (child) {\n    return matches(child, selector);\n  }) : children2;\n}\n\nfunction child(parent, selector) {\n  return selector ? children(parent, selector)[0] : parent.firstElementChild;\n}\n\nvar ownKeys = Object.keys;\n\nfunction forOwn(object, iteratee, right) {\n  if (object) {\n    var keys = ownKeys(object);\n    keys = right ? keys.reverse() : keys;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== \"__proto__\") {\n        if (iteratee(object[key], key) === false) {\n          break;\n        }\n      }\n    }\n  }\n\n  return object;\n}\n\nfunction assign(object) {\n  slice(arguments, 1).forEach(function (source) {\n    forOwn(source, function (value, key) {\n      object[key] = source[key];\n    });\n  });\n  return object;\n}\n\nfunction merge(object) {\n  slice(arguments, 1).forEach(function (source) {\n    forOwn(source, function (value, key) {\n      if (isArray(value)) {\n        object[key] = value.slice();\n      } else if (isObject(value)) {\n        object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);\n      } else {\n        object[key] = value;\n      }\n    });\n  });\n  return object;\n}\n\nfunction omit(object, keys) {\n  toArray(keys || ownKeys(object)).forEach(function (key) {\n    delete object[key];\n  });\n}\n\nfunction removeAttribute(elms, attrs) {\n  forEach(elms, function (elm) {\n    forEach(attrs, function (attr) {\n      elm && elm.removeAttribute(attr);\n    });\n  });\n}\n\nfunction setAttribute(elms, attrs, value) {\n  if (isObject(attrs)) {\n    forOwn(attrs, function (value2, name) {\n      setAttribute(elms, name, value2);\n    });\n  } else {\n    forEach(elms, function (elm) {\n      isNull(value) || value === \"\" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n    });\n  }\n}\n\nfunction create(tag, attrs, parent) {\n  var elm = document.createElement(tag);\n\n  if (attrs) {\n    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);\n  }\n\n  parent && append(parent, elm);\n  return elm;\n}\n\nfunction style(elm, prop, value) {\n  if (isUndefined(value)) {\n    return getComputedStyle(elm)[prop];\n  }\n\n  if (!isNull(value)) {\n    elm.style[prop] = \"\" + value;\n  }\n}\n\nfunction display(elm, display2) {\n  style(elm, \"display\", display2);\n}\n\nfunction focus(elm) {\n  elm[\"setActive\"] && elm[\"setActive\"]() || elm.focus({\n    preventScroll: true\n  });\n}\n\nfunction getAttribute(elm, attr) {\n  return elm.getAttribute(attr);\n}\n\nfunction hasClass(elm, className) {\n  return elm && elm.classList.contains(className);\n}\n\nfunction rect(target) {\n  return target.getBoundingClientRect();\n}\n\nfunction remove(nodes) {\n  forEach(nodes, function (node) {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n}\n\nfunction parseHtml(html) {\n  return child(new DOMParser().parseFromString(html, \"text/html\").body);\n}\n\nfunction prevent(e, stopPropagation) {\n  e.preventDefault();\n\n  if (stopPropagation) {\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n  }\n}\n\nfunction query(parent, selector) {\n  return parent && parent.querySelector(selector);\n}\n\nfunction queryAll(parent, selector) {\n  return selector ? slice(parent.querySelectorAll(selector)) : [];\n}\n\nfunction removeClass(elm, classes) {\n  toggleClass(elm, classes, false);\n}\n\nfunction timeOf(e) {\n  return e.timeStamp;\n}\n\nfunction unit(value) {\n  return isString(value) ? value : value ? value + \"px\" : \"\";\n}\n\nvar PROJECT_CODE = \"splide\";\nvar DATA_ATTRIBUTE = \"data-\" + PROJECT_CODE;\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"[\" + PROJECT_CODE + \"] \" + (message || \"\"));\n  }\n}\n\nvar min = Math.min,\n    max = Math.max,\n    floor = Math.floor,\n    ceil = Math.ceil,\n    abs = Math.abs;\n\nfunction approximatelyEqual(x, y, epsilon) {\n  return abs(x - y) < epsilon;\n}\n\nfunction between(number, minOrMax, maxOrMin, exclusive) {\n  var minimum = min(minOrMax, maxOrMin);\n  var maximum = max(minOrMax, maxOrMin);\n  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;\n}\n\nfunction clamp(number, x, y) {\n  var minimum = min(x, y);\n  var maximum = max(x, y);\n  return min(max(minimum, number), maximum);\n}\n\nfunction sign(x) {\n  return +(x > 0) - +(x < 0);\n}\n\nfunction camelToKebab(string) {\n  return string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nfunction format(string, replacements) {\n  forEach(replacements, function (replacement) {\n    string = string.replace(\"%s\", \"\" + replacement);\n  });\n  return string;\n}\n\nfunction pad(number) {\n  return number < 10 ? \"0\" + number : \"\" + number;\n}\n\nvar ids = {};\n\nfunction uniqueId(prefix) {\n  return \"\" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);\n}\n\nfunction EventBinder() {\n  var listeners = [];\n\n  function bind(targets, events, callback, options) {\n    forEachEvent(targets, events, function (target, event, namespace) {\n      var isEventTarget = (\"addEventListener\" in target);\n      var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target[\"removeListener\"].bind(target, callback);\n      isEventTarget ? target.addEventListener(event, callback, options) : target[\"addListener\"](callback);\n      listeners.push([target, event, namespace, callback, remover]);\n    });\n  }\n\n  function unbind(targets, events, callback) {\n    forEachEvent(targets, events, function (target, event, namespace) {\n      listeners = listeners.filter(function (listener) {\n        if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {\n          listener[4]();\n          return false;\n        }\n\n        return true;\n      });\n    });\n  }\n\n  function dispatch(target, type, detail) {\n    var e;\n    var bubbles = true;\n\n    if (typeof CustomEvent === \"function\") {\n      e = new CustomEvent(type, {\n        bubbles: bubbles,\n        detail: detail\n      });\n    } else {\n      e = document.createEvent(\"CustomEvent\");\n      e.initCustomEvent(type, bubbles, false, detail);\n    }\n\n    target.dispatchEvent(e);\n    return e;\n  }\n\n  function forEachEvent(targets, events, iteratee) {\n    forEach(targets, function (target) {\n      target && forEach(events, function (events2) {\n        events2.split(\" \").forEach(function (eventNS) {\n          var fragment = eventNS.split(\".\");\n          iteratee(target, fragment[0], fragment[1]);\n        });\n      });\n    });\n  }\n\n  function destroy() {\n    listeners.forEach(function (data) {\n      data[4]();\n    });\n    empty(listeners);\n  }\n\n  return {\n    bind: bind,\n    unbind: unbind,\n    dispatch: dispatch,\n    destroy: destroy\n  };\n}\n\nvar EVENT_MOUNTED = \"mounted\";\nvar EVENT_READY = \"ready\";\nvar EVENT_MOVE = \"move\";\nvar EVENT_MOVED = \"moved\";\nvar EVENT_SHIFTED = \"shifted\";\nvar EVENT_CLICK = \"click\";\nvar EVENT_ACTIVE = \"active\";\nvar EVENT_INACTIVE = \"inactive\";\nvar EVENT_VISIBLE = \"visible\";\nvar EVENT_HIDDEN = \"hidden\";\nvar EVENT_SLIDE_KEYDOWN = \"slide:keydown\";\nvar EVENT_REFRESH = \"refresh\";\nvar EVENT_UPDATED = \"updated\";\nvar EVENT_RESIZE = \"resize\";\nvar EVENT_RESIZED = \"resized\";\nvar EVENT_DRAG = \"drag\";\nvar EVENT_DRAGGING = \"dragging\";\nvar EVENT_DRAGGED = \"dragged\";\nvar EVENT_SCROLL = \"scroll\";\nvar EVENT_SCROLLED = \"scrolled\";\nvar EVENT_DESTROY = \"destroy\";\nvar EVENT_ARROWS_MOUNTED = \"arrows:mounted\";\nvar EVENT_ARROWS_UPDATED = \"arrows:updated\";\nvar EVENT_PAGINATION_MOUNTED = \"pagination:mounted\";\nvar EVENT_PAGINATION_UPDATED = \"pagination:updated\";\nvar EVENT_NAVIGATION_MOUNTED = \"navigation:mounted\";\nvar EVENT_AUTOPLAY_PLAY = \"autoplay:play\";\nvar EVENT_AUTOPLAY_PLAYING = \"autoplay:playing\";\nvar EVENT_AUTOPLAY_PAUSE = \"autoplay:pause\";\nvar EVENT_LAZYLOAD_LOADED = \"lazyload:loaded\";\n\nfunction EventInterface(Splide2) {\n  var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();\n  var binder = EventBinder();\n\n  function on(events, callback) {\n    binder.bind(bus, toArray(events).join(\" \"), function (e) {\n      callback.apply(callback, isArray(e.detail) ? e.detail : []);\n    });\n  }\n\n  function emit(event) {\n    binder.dispatch(bus, event, slice(arguments, 1));\n  }\n\n  if (Splide2) {\n    Splide2.event.on(EVENT_DESTROY, binder.destroy);\n  }\n\n  return assign(binder, {\n    bus: bus,\n    on: on,\n    off: apply(binder.unbind, bus),\n    emit: emit\n  });\n}\n\nfunction RequestInterval(interval, onInterval, onUpdate, limit) {\n  var now = Date.now;\n  var startTime;\n  var rate = 0;\n  var id;\n  var paused = true;\n  var count = 0;\n\n  function update() {\n    if (!paused) {\n      rate = interval ? min((now() - startTime) / interval, 1) : 1;\n      onUpdate && onUpdate(rate);\n\n      if (rate >= 1) {\n        onInterval();\n        startTime = now();\n\n        if (limit && ++count >= limit) {\n          return pause();\n        }\n      }\n\n      raf(update);\n    }\n  }\n\n  function start(resume) {\n    !resume && cancel();\n    startTime = now() - (resume ? rate * interval : 0);\n    paused = false;\n    raf(update);\n  }\n\n  function pause() {\n    paused = true;\n  }\n\n  function rewind() {\n    startTime = now();\n    rate = 0;\n\n    if (onUpdate) {\n      onUpdate(rate);\n    }\n  }\n\n  function cancel() {\n    id && cancelAnimationFrame(id);\n    rate = 0;\n    id = 0;\n    paused = true;\n  }\n\n  function set(time) {\n    interval = time;\n  }\n\n  function isPaused() {\n    return paused;\n  }\n\n  return {\n    start: start,\n    rewind: rewind,\n    pause: pause,\n    cancel: cancel,\n    set: set,\n    isPaused: isPaused\n  };\n}\n\nfunction State(initialState) {\n  var state = initialState;\n\n  function set(value) {\n    state = value;\n  }\n\n  function is(states) {\n    return includes(toArray(states), state);\n  }\n\n  return {\n    set: set,\n    is: is\n  };\n}\n\nfunction Throttle(func, duration) {\n  var interval;\n\n  function throttled() {\n    if (!interval) {\n      interval = RequestInterval(duration || 0, function () {\n        func();\n        interval = null;\n      }, null, 1);\n      interval.start();\n    }\n  }\n\n  return throttled;\n}\n\nfunction Media(Splide2, Components2, options) {\n  var state = Splide2.state;\n  var breakpoints = options.breakpoints || {};\n  var reducedMotion = options.reducedMotion || {};\n  var binder = EventBinder();\n  var queries = [];\n\n  function setup() {\n    var isMin = options.mediaQuery === \"min\";\n    ownKeys(breakpoints).sort(function (n, m) {\n      return isMin ? +n - +m : +m - +n;\n    }).forEach(function (key) {\n      register(breakpoints[key], \"(\" + (isMin ? \"min\" : \"max\") + \"-width:\" + key + \"px)\");\n    });\n    register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);\n    update();\n  }\n\n  function destroy(completely) {\n    if (completely) {\n      binder.destroy();\n    }\n  }\n\n  function register(options2, query) {\n    var queryList = matchMedia(query);\n    binder.bind(queryList, \"change\", update);\n    queries.push([options2, queryList]);\n  }\n\n  function update() {\n    var destroyed = state.is(DESTROYED);\n    var direction = options.direction;\n    var merged = queries.reduce(function (merged2, entry) {\n      return merge(merged2, entry[1].matches ? entry[0] : {});\n    }, {});\n    omit(options);\n    set(merged);\n\n    if (options.destroy) {\n      Splide2.destroy(options.destroy === \"completely\");\n    } else if (destroyed) {\n      destroy(true);\n      Splide2.mount();\n    } else {\n      direction !== options.direction && Splide2.refresh();\n    }\n  }\n\n  function reduce(enable) {\n    if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {\n      enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));\n    }\n  }\n\n  function set(opts, user) {\n    merge(options, opts);\n    user && merge(Object.getPrototypeOf(options), opts);\n\n    if (!state.is(CREATED)) {\n      Splide2.emit(EVENT_UPDATED, options);\n    }\n  }\n\n  return {\n    setup: setup,\n    destroy: destroy,\n    reduce: reduce,\n    set: set\n  };\n}\n\nvar ARROW = \"Arrow\";\nvar ARROW_LEFT = ARROW + \"Left\";\nvar ARROW_RIGHT = ARROW + \"Right\";\nvar ARROW_UP = ARROW + \"Up\";\nvar ARROW_DOWN = ARROW + \"Down\";\nvar LTR = \"ltr\";\nvar RTL = \"rtl\";\nvar TTB = \"ttb\";\nvar ORIENTATION_MAP = {\n  width: [\"height\"],\n  left: [\"top\", \"right\"],\n  right: [\"bottom\", \"left\"],\n  x: [\"y\"],\n  X: [\"Y\"],\n  Y: [\"X\"],\n  ArrowLeft: [ARROW_UP, ARROW_RIGHT],\n  ArrowRight: [ARROW_DOWN, ARROW_LEFT]\n};\n\nfunction Direction(Splide2, Components2, options) {\n  function resolve(prop, axisOnly, direction) {\n    direction = direction || options.direction;\n    var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;\n    return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function (match, offset) {\n      var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;\n      return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;\n    });\n  }\n\n  function orient(value) {\n    return value * (options.direction === RTL ? 1 : -1);\n  }\n\n  return {\n    resolve: resolve,\n    orient: orient\n  };\n}\n\nvar ROLE = \"role\";\nvar TAB_INDEX = \"tabindex\";\nvar DISABLED = \"disabled\";\nvar ARIA_PREFIX = \"aria-\";\nvar ARIA_CONTROLS = ARIA_PREFIX + \"controls\";\nvar ARIA_CURRENT = ARIA_PREFIX + \"current\";\nvar ARIA_SELECTED = ARIA_PREFIX + \"selected\";\nvar ARIA_LABEL = ARIA_PREFIX + \"label\";\nvar ARIA_LABELLEDBY = ARIA_PREFIX + \"labelledby\";\nvar ARIA_HIDDEN = ARIA_PREFIX + \"hidden\";\nvar ARIA_ORIENTATION = ARIA_PREFIX + \"orientation\";\nvar ARIA_ROLEDESCRIPTION = ARIA_PREFIX + \"roledescription\";\nvar ARIA_LIVE = ARIA_PREFIX + \"live\";\nvar ARIA_BUSY = ARIA_PREFIX + \"busy\";\nvar ARIA_ATOMIC = ARIA_PREFIX + \"atomic\";\nvar ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];\nvar CLASS_ROOT = PROJECT_CODE;\nvar CLASS_TRACK = PROJECT_CODE + \"__track\";\nvar CLASS_LIST = PROJECT_CODE + \"__list\";\nvar CLASS_SLIDE = PROJECT_CODE + \"__slide\";\nvar CLASS_CLONE = CLASS_SLIDE + \"--clone\";\nvar CLASS_CONTAINER = CLASS_SLIDE + \"__container\";\nvar CLASS_ARROWS = PROJECT_CODE + \"__arrows\";\nvar CLASS_ARROW = PROJECT_CODE + \"__arrow\";\nvar CLASS_ARROW_PREV = CLASS_ARROW + \"--prev\";\nvar CLASS_ARROW_NEXT = CLASS_ARROW + \"--next\";\nvar CLASS_PAGINATION = PROJECT_CODE + \"__pagination\";\nvar CLASS_PAGINATION_PAGE = CLASS_PAGINATION + \"__page\";\nvar CLASS_PROGRESS = PROJECT_CODE + \"__progress\";\nvar CLASS_PROGRESS_BAR = CLASS_PROGRESS + \"__bar\";\nvar CLASS_TOGGLE = PROJECT_CODE + \"__toggle\";\nvar CLASS_TOGGLE_PLAY = CLASS_TOGGLE + \"__play\";\nvar CLASS_TOGGLE_PAUSE = CLASS_TOGGLE + \"__pause\";\nvar CLASS_SPINNER = PROJECT_CODE + \"__spinner\";\nvar CLASS_SR = PROJECT_CODE + \"__sr\";\nvar CLASS_INITIALIZED = \"is-initialized\";\nvar CLASS_ACTIVE = \"is-active\";\nvar CLASS_PREV = \"is-prev\";\nvar CLASS_NEXT = \"is-next\";\nvar CLASS_VISIBLE = \"is-visible\";\nvar CLASS_LOADING = \"is-loading\";\nvar CLASS_FOCUS_IN = \"is-focus-in\";\nvar STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN];\nvar CLASSES = {\n  slide: CLASS_SLIDE,\n  clone: CLASS_CLONE,\n  arrows: CLASS_ARROWS,\n  arrow: CLASS_ARROW,\n  prev: CLASS_ARROW_PREV,\n  next: CLASS_ARROW_NEXT,\n  pagination: CLASS_PAGINATION,\n  page: CLASS_PAGINATION_PAGE,\n  spinner: CLASS_SPINNER\n};\n\nfunction closest(from, selector) {\n  if (isFunction(from.closest)) {\n    return from.closest(selector);\n  }\n\n  var elm = from;\n\n  while (elm && elm.nodeType === 1) {\n    if (matches(elm, selector)) {\n      break;\n    }\n\n    elm = elm.parentElement;\n  }\n\n  return elm;\n}\n\nvar FRICTION = 5;\nvar LOG_INTERVAL = 200;\nvar POINTER_DOWN_EVENTS = \"touchstart mousedown\";\nvar POINTER_MOVE_EVENTS = \"touchmove mousemove\";\nvar POINTER_UP_EVENTS = \"touchend touchcancel mouseup click\";\n\nfunction Elements(Splide2, Components2, options) {\n  var _EventInterface = EventInterface(Splide2),\n      on = _EventInterface.on,\n      bind = _EventInterface.bind;\n\n  var root = Splide2.root;\n  var i18n = options.i18n;\n  var elements = {};\n  var slides = [];\n  var rootClasses = [];\n  var trackClasses = [];\n  var track;\n  var list;\n  var isUsingKey;\n\n  function setup() {\n    collect();\n    init();\n    update();\n  }\n\n  function mount() {\n    on(EVENT_REFRESH, destroy);\n    on(EVENT_REFRESH, setup);\n    on(EVENT_UPDATED, update);\n    bind(document, POINTER_DOWN_EVENTS + \" keydown\", function (e) {\n      isUsingKey = e.type === \"keydown\";\n    }, {\n      capture: true\n    });\n    bind(root, \"focusin\", function () {\n      toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);\n    });\n  }\n\n  function destroy(completely) {\n    var attrs = ALL_ATTRIBUTES.concat(\"style\");\n    empty(slides);\n    removeClass(root, rootClasses);\n    removeClass(track, trackClasses);\n    removeAttribute([track, list], attrs);\n    removeAttribute(root, completely ? attrs : [\"style\", ARIA_ROLEDESCRIPTION]);\n  }\n\n  function update() {\n    removeClass(root, rootClasses);\n    removeClass(track, trackClasses);\n    rootClasses = getClasses(CLASS_ROOT);\n    trackClasses = getClasses(CLASS_TRACK);\n    addClass(root, rootClasses);\n    addClass(track, trackClasses);\n    setAttribute(root, ARIA_LABEL, options.label);\n    setAttribute(root, ARIA_LABELLEDBY, options.labelledby);\n  }\n\n  function collect() {\n    track = find(\".\" + CLASS_TRACK);\n    list = child(track, \".\" + CLASS_LIST);\n    assert(track && list, \"A track/list element is missing.\");\n    push(slides, children(list, \".\" + CLASS_SLIDE + \":not(.\" + CLASS_CLONE + \")\"));\n    forOwn({\n      arrows: CLASS_ARROWS,\n      pagination: CLASS_PAGINATION,\n      prev: CLASS_ARROW_PREV,\n      next: CLASS_ARROW_NEXT,\n      bar: CLASS_PROGRESS_BAR,\n      toggle: CLASS_TOGGLE\n    }, function (className, key) {\n      elements[key] = find(\".\" + className);\n    });\n    assign(elements, {\n      root: root,\n      track: track,\n      list: list,\n      slides: slides\n    });\n  }\n\n  function init() {\n    var id = root.id || uniqueId(PROJECT_CODE);\n    var role = options.role;\n    root.id = id;\n    track.id = track.id || id + \"-track\";\n    list.id = list.id || id + \"-list\";\n\n    if (!getAttribute(root, ROLE) && root.tagName !== \"SECTION\" && role) {\n      setAttribute(root, ROLE, role);\n    }\n\n    setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);\n    setAttribute(list, ROLE, \"presentation\");\n  }\n\n  function find(selector) {\n    var elm = query(root, selector);\n    return elm && closest(elm, \".\" + CLASS_ROOT) === root ? elm : void 0;\n  }\n\n  function getClasses(base) {\n    return [base + \"--\" + options.type, base + \"--\" + options.direction, options.drag && base + \"--draggable\", options.isNavigation && base + \"--nav\", base === CLASS_ROOT && CLASS_ACTIVE];\n  }\n\n  return assign(elements, {\n    setup: setup,\n    mount: mount,\n    destroy: destroy\n  });\n}\n\nvar SLIDE = \"slide\";\nvar LOOP = \"loop\";\nvar FADE = \"fade\";\n\nfunction Slide$1(Splide2, index, slideIndex, slide) {\n  var event = EventInterface(Splide2);\n  var on = event.on,\n      emit = event.emit,\n      bind = event.bind;\n  var Components = Splide2.Components,\n      root = Splide2.root,\n      options = Splide2.options;\n  var isNavigation = options.isNavigation,\n      updateOnMove = options.updateOnMove,\n      i18n = options.i18n,\n      pagination = options.pagination,\n      slideFocus = options.slideFocus;\n  var resolve = Components.Direction.resolve;\n  var styles = getAttribute(slide, \"style\");\n  var label = getAttribute(slide, ARIA_LABEL);\n  var isClone = slideIndex > -1;\n  var container = child(slide, \".\" + CLASS_CONTAINER);\n  var destroyed;\n\n  function mount() {\n    if (!isClone) {\n      slide.id = root.id + \"-slide\" + pad(index + 1);\n      setAttribute(slide, ROLE, pagination ? \"tabpanel\" : \"group\");\n      setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);\n      setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));\n    }\n\n    listen();\n  }\n\n  function listen() {\n    bind(slide, \"click\", apply(emit, EVENT_CLICK, self));\n    bind(slide, \"keydown\", apply(emit, EVENT_SLIDE_KEYDOWN, self));\n    on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);\n    on(EVENT_NAVIGATION_MOUNTED, initNavigation);\n\n    if (updateOnMove) {\n      on(EVENT_MOVE, onMove);\n    }\n  }\n\n  function destroy() {\n    destroyed = true;\n    event.destroy();\n    removeClass(slide, STATUS_CLASSES);\n    removeAttribute(slide, ALL_ATTRIBUTES);\n    setAttribute(slide, \"style\", styles);\n    setAttribute(slide, ARIA_LABEL, label || \"\");\n  }\n\n  function initNavigation() {\n    var controls = Splide2.splides.map(function (target) {\n      var Slide2 = target.splide.Components.Slides.getAt(index);\n      return Slide2 ? Slide2.slide.id : \"\";\n    }).join(\" \");\n    setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));\n    setAttribute(slide, ARIA_CONTROLS, controls);\n    setAttribute(slide, ROLE, slideFocus ? \"button\" : \"\");\n    slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);\n  }\n\n  function onMove() {\n    if (!destroyed) {\n      update();\n    }\n  }\n\n  function update() {\n    if (!destroyed) {\n      var curr = Splide2.index;\n      updateActivity();\n      updateVisibility();\n      toggleClass(slide, CLASS_PREV, index === curr - 1);\n      toggleClass(slide, CLASS_NEXT, index === curr + 1);\n    }\n  }\n\n  function updateActivity() {\n    var active = isActive();\n\n    if (active !== hasClass(slide, CLASS_ACTIVE)) {\n      toggleClass(slide, CLASS_ACTIVE, active);\n      setAttribute(slide, ARIA_CURRENT, isNavigation && active || \"\");\n      emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);\n    }\n  }\n\n  function updateVisibility() {\n    var visible = isVisible();\n    var hidden = !visible && (!isActive() || isClone);\n\n    if (!Splide2.state.is([MOVING, SCROLLING])) {\n      setAttribute(slide, ARIA_HIDDEN, hidden || \"\");\n    }\n\n    setAttribute(queryAll(slide, options.focusableNodes || \"\"), TAB_INDEX, hidden ? -1 : \"\");\n\n    if (slideFocus) {\n      setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);\n    }\n\n    if (visible !== hasClass(slide, CLASS_VISIBLE)) {\n      toggleClass(slide, CLASS_VISIBLE, visible);\n      emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);\n    }\n\n    if (!visible && document.activeElement === slide) {\n      var Slide2 = Components.Slides.getAt(Splide2.index);\n      Slide2 && focus(Slide2.slide);\n    }\n  }\n\n  function style$1(prop, value, useContainer) {\n    style(useContainer && container || slide, prop, value);\n  }\n\n  function isActive() {\n    var curr = Splide2.index;\n    return curr === index || options.cloneStatus && curr === slideIndex;\n  }\n\n  function isVisible() {\n    if (Splide2.is(FADE)) {\n      return isActive();\n    }\n\n    var trackRect = rect(Components.Elements.track);\n    var slideRect = rect(slide);\n    var left = resolve(\"left\", true);\n    var right = resolve(\"right\", true);\n    return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);\n  }\n\n  function isWithin(from, distance) {\n    var diff = abs(from - index);\n\n    if (!isClone && (options.rewind || Splide2.is(LOOP))) {\n      diff = min(diff, Splide2.length - diff);\n    }\n\n    return diff <= distance;\n  }\n\n  var self = {\n    index: index,\n    slideIndex: slideIndex,\n    slide: slide,\n    container: container,\n    isClone: isClone,\n    mount: mount,\n    destroy: destroy,\n    update: update,\n    style: style$1,\n    isWithin: isWithin\n  };\n  return self;\n}\n\nfunction Slides(Splide2, Components2, options) {\n  var _EventInterface2 = EventInterface(Splide2),\n      on = _EventInterface2.on,\n      emit = _EventInterface2.emit,\n      bind = _EventInterface2.bind;\n\n  var _Components2$Elements = Components2.Elements,\n      slides = _Components2$Elements.slides,\n      list = _Components2$Elements.list;\n  var Slides2 = [];\n\n  function mount() {\n    init();\n    on(EVENT_REFRESH, destroy);\n    on(EVENT_REFRESH, init);\n    on([EVENT_MOUNTED, EVENT_REFRESH], function () {\n      Slides2.sort(function (Slide1, Slide2) {\n        return Slide1.index - Slide2.index;\n      });\n    });\n  }\n\n  function init() {\n    slides.forEach(function (slide, index) {\n      register(slide, index, -1);\n    });\n  }\n\n  function destroy() {\n    forEach$1(function (Slide2) {\n      Slide2.destroy();\n    });\n    empty(Slides2);\n  }\n\n  function update() {\n    forEach$1(function (Slide2) {\n      Slide2.update();\n    });\n  }\n\n  function register(slide, index, slideIndex) {\n    var object = Slide$1(Splide2, index, slideIndex, slide);\n    object.mount();\n    Slides2.push(object);\n  }\n\n  function get(excludeClones) {\n    return excludeClones ? filter(function (Slide2) {\n      return !Slide2.isClone;\n    }) : Slides2;\n  }\n\n  function getIn(page) {\n    var Controller = Components2.Controller;\n    var index = Controller.toIndex(page);\n    var max = Controller.hasFocus() ? 1 : options.perPage;\n    return filter(function (Slide2) {\n      return between(Slide2.index, index, index + max - 1);\n    });\n  }\n\n  function getAt(index) {\n    return filter(index)[0];\n  }\n\n  function add(items, index) {\n    forEach(items, function (slide) {\n      if (isString(slide)) {\n        slide = parseHtml(slide);\n      }\n\n      if (isHTMLElement(slide)) {\n        var ref = slides[index];\n        ref ? before(slide, ref) : append(list, slide);\n        addClass(slide, options.classes.slide);\n        observeImages(slide, apply(emit, EVENT_RESIZE));\n      }\n    });\n    emit(EVENT_REFRESH);\n  }\n\n  function remove$1(matcher) {\n    remove(filter(matcher).map(function (Slide2) {\n      return Slide2.slide;\n    }));\n    emit(EVENT_REFRESH);\n  }\n\n  function forEach$1(iteratee, excludeClones) {\n    get(excludeClones).forEach(iteratee);\n  }\n\n  function filter(matcher) {\n    return Slides2.filter(isFunction(matcher) ? matcher : function (Slide2) {\n      return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);\n    });\n  }\n\n  function style(prop, value, useContainer) {\n    forEach$1(function (Slide2) {\n      Slide2.style(prop, value, useContainer);\n    });\n  }\n\n  function observeImages(elm, callback) {\n    var images = queryAll(elm, \"img\");\n    var length = images.length;\n\n    if (length) {\n      images.forEach(function (img) {\n        bind(img, \"load error\", function () {\n          if (! --length) {\n            callback();\n          }\n        });\n      });\n    } else {\n      callback();\n    }\n  }\n\n  function getLength(excludeClones) {\n    return excludeClones ? slides.length : Slides2.length;\n  }\n\n  function isEnough() {\n    return Slides2.length > options.perPage;\n  }\n\n  return {\n    mount: mount,\n    destroy: destroy,\n    update: update,\n    register: register,\n    get: get,\n    getIn: getIn,\n    getAt: getAt,\n    add: add,\n    remove: remove$1,\n    forEach: forEach$1,\n    filter: filter,\n    style: style,\n    getLength: getLength,\n    isEnough: isEnough\n  };\n}\n\nfunction Layout(Splide2, Components2, options) {\n  var _EventInterface3 = EventInterface(Splide2),\n      on = _EventInterface3.on,\n      bind = _EventInterface3.bind,\n      emit = _EventInterface3.emit;\n\n  var Slides = Components2.Slides;\n  var resolve = Components2.Direction.resolve;\n  var _Components2$Elements2 = Components2.Elements,\n      root = _Components2$Elements2.root,\n      track = _Components2$Elements2.track,\n      list = _Components2$Elements2.list;\n  var getAt = Slides.getAt,\n      styleSlides = Slides.style;\n  var vertical;\n  var rootRect;\n\n  function mount() {\n    init();\n    bind(window, \"resize load\", Throttle(apply(emit, EVENT_RESIZE)));\n    on([EVENT_UPDATED, EVENT_REFRESH], init);\n    on(EVENT_RESIZE, resize);\n  }\n\n  function init() {\n    rootRect = null;\n    vertical = options.direction === TTB;\n    style(root, \"maxWidth\", unit(options.width));\n    style(track, resolve(\"paddingLeft\"), cssPadding(false));\n    style(track, resolve(\"paddingRight\"), cssPadding(true));\n    resize();\n  }\n\n  function resize() {\n    var newRect = rect(root);\n\n    if (!rootRect || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {\n      style(track, \"height\", cssTrackHeight());\n      styleSlides(resolve(\"marginRight\"), unit(options.gap));\n      styleSlides(\"width\", cssSlideWidth());\n      styleSlides(\"height\", cssSlideHeight(), true);\n      rootRect = newRect;\n      emit(EVENT_RESIZED);\n    }\n  }\n\n  function cssPadding(right) {\n    var padding = options.padding;\n    var prop = resolve(right ? \"right\" : \"left\");\n    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n  }\n\n  function cssTrackHeight() {\n    var height = \"\";\n\n    if (vertical) {\n      height = cssHeight();\n      assert(height, \"height or heightRatio is missing.\");\n      height = \"calc(\" + height + \" - \" + cssPadding(false) + \" - \" + cssPadding(true) + \")\";\n    }\n\n    return height;\n  }\n\n  function cssHeight() {\n    return unit(options.height || rect(list).width * options.heightRatio);\n  }\n\n  function cssSlideWidth() {\n    return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? \"\" : cssSlideSize());\n  }\n\n  function cssSlideHeight() {\n    return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());\n  }\n\n  function cssSlideSize() {\n    var gap = unit(options.gap);\n    return \"calc((100%\" + (gap && \" + \" + gap) + \")/\" + (options.perPage || 1) + (gap && \" - \" + gap) + \")\";\n  }\n\n  function listSize() {\n    return rect(list)[resolve(\"width\")];\n  }\n\n  function slideSize(index, withoutGap) {\n    var Slide = getAt(index || 0);\n    return Slide ? rect(Slide.slide)[resolve(\"width\")] + (withoutGap ? 0 : getGap()) : 0;\n  }\n\n  function totalSize(index, withoutGap) {\n    var Slide = getAt(index);\n\n    if (Slide) {\n      var right = rect(Slide.slide)[resolve(\"right\")];\n      var left = rect(list)[resolve(\"left\")];\n      return abs(right - left) + (withoutGap ? 0 : getGap());\n    }\n\n    return 0;\n  }\n\n  function sliderSize() {\n    return totalSize(Splide2.length - 1, true) - totalSize(-1, true);\n  }\n\n  function getGap() {\n    var Slide = getAt(0);\n    return Slide && parseFloat(style(Slide.slide, resolve(\"marginRight\"))) || 0;\n  }\n\n  function getPadding(right) {\n    return parseFloat(style(track, resolve(\"padding\" + (right ? \"Right\" : \"Left\")))) || 0;\n  }\n\n  return {\n    mount: mount,\n    listSize: listSize,\n    slideSize: slideSize,\n    sliderSize: sliderSize,\n    totalSize: totalSize,\n    getPadding: getPadding\n  };\n}\n\nvar MULTIPLIER = 2;\n\nfunction Clones(Splide2, Components2, options) {\n  var _EventInterface4 = EventInterface(Splide2),\n      on = _EventInterface4.on,\n      emit = _EventInterface4.emit;\n\n  var Elements = Components2.Elements,\n      Slides = Components2.Slides;\n  var resolve = Components2.Direction.resolve;\n  var clones = [];\n  var cloneCount;\n\n  function mount() {\n    init();\n    on(EVENT_REFRESH, destroy);\n    on(EVENT_REFRESH, init);\n    on([EVENT_UPDATED, EVENT_RESIZE], observe);\n  }\n\n  function init() {\n    if (cloneCount = computeCloneCount()) {\n      generate(cloneCount);\n      emit(EVENT_RESIZE);\n    }\n  }\n\n  function destroy() {\n    remove(clones);\n    empty(clones);\n  }\n\n  function observe() {\n    if (cloneCount < computeCloneCount()) {\n      emit(EVENT_REFRESH);\n    }\n  }\n\n  function generate(count) {\n    var slides = Slides.get().slice();\n    var length = slides.length;\n\n    if (length) {\n      while (slides.length < count) {\n        push(slides, slides);\n      }\n\n      push(slides.slice(-count), slides.slice(0, count)).forEach(function (Slide, index) {\n        var isHead = index < count;\n        var clone = cloneDeep(Slide.slide, index);\n        isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);\n        push(clones, clone);\n        Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);\n      });\n    }\n  }\n\n  function cloneDeep(elm, index) {\n    var clone = elm.cloneNode(true);\n    addClass(clone, options.classes.clone);\n    clone.id = Splide2.root.id + \"-clone\" + pad(index + 1);\n    return clone;\n  }\n\n  function computeCloneCount() {\n    var clones2 = options.clones;\n\n    if (!Splide2.is(LOOP)) {\n      clones2 = 0;\n    } else if (!clones2) {\n      var fixedSize = options[resolve(\"fixedWidth\")] && Components2.Layout.slideSize(0);\n      var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve(\"width\")] / fixedSize);\n      clones2 = fixedCount || options[resolve(\"autoWidth\")] && Splide2.length || options.perPage * MULTIPLIER;\n    }\n\n    return clones2;\n  }\n\n  return {\n    mount: mount,\n    destroy: destroy\n  };\n}\n\nfunction Move(Splide2, Components2, options) {\n  var _EventInterface5 = EventInterface(Splide2),\n      on = _EventInterface5.on,\n      emit = _EventInterface5.emit;\n\n  var set = Splide2.state.set;\n  var _Components2$Layout = Components2.Layout,\n      slideSize = _Components2$Layout.slideSize,\n      getPadding = _Components2$Layout.getPadding,\n      totalSize = _Components2$Layout.totalSize,\n      listSize = _Components2$Layout.listSize,\n      sliderSize = _Components2$Layout.sliderSize;\n  var _Components2$Directio = Components2.Direction,\n      resolve = _Components2$Directio.resolve,\n      orient = _Components2$Directio.orient;\n  var _Components2$Elements3 = Components2.Elements,\n      list = _Components2$Elements3.list,\n      track = _Components2$Elements3.track;\n  var Transition;\n\n  function mount() {\n    Transition = Components2.Transition;\n    on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);\n  }\n\n  function reposition() {\n    if (!Components2.Controller.isBusy()) {\n      Components2.Scroll.cancel();\n      jump(Splide2.index);\n      Components2.Slides.update();\n    }\n  }\n\n  function move(dest, index, prev, callback) {\n    if (dest !== index && canShift(dest > prev)) {\n      cancel();\n      translate(shift(getPosition(), dest > prev), true);\n    }\n\n    set(MOVING);\n    emit(EVENT_MOVE, index, prev, dest);\n    Transition.start(index, function () {\n      set(IDLE);\n      emit(EVENT_MOVED, index, prev, dest);\n      callback && callback();\n    });\n  }\n\n  function jump(index) {\n    translate(toPosition(index, true));\n  }\n\n  function translate(position, preventLoop) {\n    if (!Splide2.is(FADE)) {\n      var destination = preventLoop ? position : loop(position);\n      style(list, \"transform\", \"translate\" + resolve(\"X\") + \"(\" + destination + \"px)\");\n      position !== destination && emit(EVENT_SHIFTED);\n    }\n  }\n\n  function loop(position) {\n    if (Splide2.is(LOOP)) {\n      var index = toIndex(position);\n      var exceededMax = index > Components2.Controller.getEnd();\n      var exceededMin = index < 0;\n\n      if (exceededMin || exceededMax) {\n        position = shift(position, exceededMax);\n      }\n    }\n\n    return position;\n  }\n\n  function shift(position, backwards) {\n    var excess = position - getLimit(backwards);\n    var size = sliderSize();\n    position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);\n    return position;\n  }\n\n  function cancel() {\n    translate(getPosition());\n    Transition.cancel();\n  }\n\n  function toIndex(position) {\n    var Slides = Components2.Slides.get();\n    var index = 0;\n    var minDistance = Infinity;\n\n    for (var i = 0; i < Slides.length; i++) {\n      var slideIndex = Slides[i].index;\n      var distance = abs(toPosition(slideIndex, true) - position);\n\n      if (distance <= minDistance) {\n        minDistance = distance;\n        index = slideIndex;\n      } else {\n        break;\n      }\n    }\n\n    return index;\n  }\n\n  function toPosition(index, trimming) {\n    var position = orient(totalSize(index - 1) - offset(index));\n    return trimming ? trim(position) : position;\n  }\n\n  function getPosition() {\n    var left = resolve(\"left\");\n    return rect(list)[left] - rect(track)[left] + orient(getPadding(false));\n  }\n\n  function trim(position) {\n    if (options.trimSpace && Splide2.is(SLIDE)) {\n      position = clamp(position, 0, orient(sliderSize() - listSize()));\n    }\n\n    return position;\n  }\n\n  function offset(index) {\n    var focus = options.focus;\n    return focus === \"center\" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;\n  }\n\n  function getLimit(max) {\n    return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);\n  }\n\n  function canShift(backwards) {\n    var shifted = orient(shift(getPosition(), backwards));\n    return backwards ? shifted >= 0 : shifted <= list[resolve(\"scrollWidth\")] - rect(track)[resolve(\"width\")];\n  }\n\n  function exceededLimit(max, position) {\n    position = isUndefined(position) ? getPosition() : position;\n    var exceededMin = max !== true && orient(position) < orient(getLimit(false));\n    var exceededMax = max !== false && orient(position) > orient(getLimit(true));\n    return exceededMin || exceededMax;\n  }\n\n  return {\n    mount: mount,\n    move: move,\n    jump: jump,\n    translate: translate,\n    shift: shift,\n    cancel: cancel,\n    toIndex: toIndex,\n    toPosition: toPosition,\n    getPosition: getPosition,\n    getLimit: getLimit,\n    exceededLimit: exceededLimit,\n    reposition: reposition\n  };\n}\n\nfunction Controller(Splide2, Components2, options) {\n  var _EventInterface6 = EventInterface(Splide2),\n      on = _EventInterface6.on;\n\n  var Move = Components2.Move;\n  var getPosition = Move.getPosition,\n      getLimit = Move.getLimit,\n      toPosition = Move.toPosition;\n  var _Components2$Slides = Components2.Slides,\n      isEnough = _Components2$Slides.isEnough,\n      getLength = _Components2$Slides.getLength;\n  var isLoop = Splide2.is(LOOP);\n  var isSlide = Splide2.is(SLIDE);\n  var getNext = apply(getAdjacent, false);\n  var getPrev = apply(getAdjacent, true);\n  var currIndex = options.start || 0;\n  var prevIndex = currIndex;\n  var slideCount;\n  var perMove;\n  var perPage;\n\n  function mount() {\n    init();\n    on([EVENT_UPDATED, EVENT_REFRESH], init);\n  }\n\n  function init() {\n    slideCount = getLength(true);\n    perMove = options.perMove;\n    perPage = options.perPage;\n    var index = clamp(currIndex, 0, slideCount - 1);\n\n    if (index !== currIndex) {\n      currIndex = index;\n      Move.reposition();\n    }\n  }\n\n  function go(control, allowSameIndex, callback) {\n    if (!isBusy()) {\n      var dest = parse(control);\n      var index = loop(dest);\n\n      if (index > -1 && (allowSameIndex || index !== currIndex)) {\n        setIndex(index);\n        Move.move(dest, index, prevIndex, callback);\n      }\n    }\n  }\n\n  function scroll(destination, duration, snap, callback) {\n    Components2.Scroll.scroll(destination, duration, snap, function () {\n      setIndex(loop(Move.toIndex(getPosition())));\n      callback && callback();\n    });\n  }\n\n  function parse(control) {\n    var index = currIndex;\n\n    if (isString(control)) {\n      var _ref = control.match(/([+\\-<>])(\\d+)?/) || [],\n          indicator = _ref[1],\n          number = _ref[2];\n\n      if (indicator === \"+\" || indicator === \"-\") {\n        index = computeDestIndex(currIndex + +(\"\" + indicator + (+number || 1)), currIndex);\n      } else if (indicator === \">\") {\n        index = number ? toIndex(+number) : getNext(true);\n      } else if (indicator === \"<\") {\n        index = getPrev(true);\n      }\n    } else {\n      index = isLoop ? control : clamp(control, 0, getEnd());\n    }\n\n    return index;\n  }\n\n  function getAdjacent(prev, destination) {\n    var number = perMove || (hasFocus() ? 1 : perPage);\n    var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));\n\n    if (dest === -1 && isSlide) {\n      if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {\n        return prev ? 0 : getEnd();\n      }\n    }\n\n    return destination ? dest : loop(dest);\n  }\n\n  function computeDestIndex(dest, from, snapPage) {\n    if (isEnough()) {\n      var end = getEnd();\n      var index = computeMovableDestIndex(dest);\n\n      if (index !== dest) {\n        from = dest;\n        dest = index;\n        snapPage = false;\n      }\n\n      if (dest < 0 || dest > end) {\n        if (!perMove && (between(0, dest, from, true) || between(end, from, dest, true))) {\n          dest = toIndex(toPage(dest));\n        } else {\n          if (isLoop) {\n            dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;\n          } else if (options.rewind) {\n            dest = dest < 0 ? end : 0;\n          } else {\n            dest = -1;\n          }\n        }\n      } else {\n        if (snapPage && dest !== from) {\n          dest = toIndex(toPage(from) + (dest < from ? -1 : 1));\n        }\n      }\n    } else {\n      dest = -1;\n    }\n\n    return dest;\n  }\n\n  function computeMovableDestIndex(dest) {\n    if (isSlide && options.trimSpace === \"move\" && dest !== currIndex) {\n      var position = getPosition();\n\n      while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {\n        dest < currIndex ? --dest : ++dest;\n      }\n    }\n\n    return dest;\n  }\n\n  function loop(index) {\n    return isLoop ? (index + slideCount) % slideCount || 0 : index;\n  }\n\n  function getEnd() {\n    return max(slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage), 0);\n  }\n\n  function toIndex(page) {\n    return clamp(hasFocus() ? page : perPage * page, 0, getEnd());\n  }\n\n  function toPage(index) {\n    return hasFocus() ? index : floor((index >= getEnd() ? slideCount - 1 : index) / perPage);\n  }\n\n  function toDest(destination) {\n    var closest = Move.toIndex(destination);\n    return isSlide ? clamp(closest, 0, getEnd()) : closest;\n  }\n\n  function setIndex(index) {\n    if (index !== currIndex) {\n      prevIndex = currIndex;\n      currIndex = index;\n    }\n  }\n\n  function getIndex(prev) {\n    return prev ? prevIndex : currIndex;\n  }\n\n  function hasFocus() {\n    return !isUndefined(options.focus) || options.isNavigation;\n  }\n\n  function isBusy() {\n    return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;\n  }\n\n  return {\n    mount: mount,\n    go: go,\n    scroll: scroll,\n    getNext: getNext,\n    getPrev: getPrev,\n    getAdjacent: getAdjacent,\n    getEnd: getEnd,\n    setIndex: setIndex,\n    getIndex: getIndex,\n    toIndex: toIndex,\n    toPage: toPage,\n    toDest: toDest,\n    hasFocus: hasFocus,\n    isBusy: isBusy\n  };\n}\n\nvar XML_NAME_SPACE = \"http://www.w3.org/2000/svg\";\nvar PATH = \"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z\";\nvar SIZE = 40;\n\nfunction Arrows(Splide2, Components2, options) {\n  var event = EventInterface(Splide2);\n  var on = event.on,\n      bind = event.bind,\n      emit = event.emit;\n  var classes = options.classes,\n      i18n = options.i18n;\n  var Elements = Components2.Elements,\n      Controller = Components2.Controller;\n  var userArrows = Elements.arrows,\n      track = Elements.track;\n  var wrapper = userArrows;\n  var prev = Elements.prev;\n  var next = Elements.next;\n  var created;\n  var wrapperClasses;\n  var arrows = {};\n\n  function mount() {\n    init();\n    on(EVENT_UPDATED, remount);\n  }\n\n  function remount() {\n    destroy();\n    mount();\n  }\n\n  function init() {\n    var enabled = options.arrows;\n\n    if (enabled && !(prev && next)) {\n      createArrows();\n    }\n\n    if (prev && next) {\n      assign(arrows, {\n        prev: prev,\n        next: next\n      });\n      display(wrapper, enabled ? \"\" : \"none\");\n      addClass(wrapper, wrapperClasses = CLASS_ARROWS + \"--\" + options.direction);\n\n      if (enabled) {\n        listen();\n        update();\n        setAttribute([prev, next], ARIA_CONTROLS, track.id);\n        emit(EVENT_ARROWS_MOUNTED, prev, next);\n      }\n    }\n  }\n\n  function destroy() {\n    event.destroy();\n    removeClass(wrapper, wrapperClasses);\n\n    if (created) {\n      remove(userArrows ? [prev, next] : wrapper);\n      prev = next = null;\n    } else {\n      removeAttribute([prev, next], ALL_ATTRIBUTES);\n    }\n  }\n\n  function listen() {\n    on([EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED], update);\n    bind(next, \"click\", apply(go, \">\"));\n    bind(prev, \"click\", apply(go, \"<\"));\n  }\n\n  function go(control) {\n    Controller.go(control, true);\n  }\n\n  function createArrows() {\n    wrapper = userArrows || create(\"div\", classes.arrows);\n    prev = createArrow(true);\n    next = createArrow(false);\n    created = true;\n    append(wrapper, [prev, next]);\n    !userArrows && before(wrapper, track);\n  }\n\n  function createArrow(prev2) {\n    var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev2 ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\"><svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\" viewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\" width=\\\"\" + SIZE + \"\\\" height=\\\"\" + SIZE + \"\\\" focusable=\\\"false\\\"><path d=\\\"\" + (options.arrowPath || PATH) + \"\\\" />\";\n    return parseHtml(arrow);\n  }\n\n  function update() {\n    var index = Splide2.index;\n    var prevIndex = Controller.getPrev();\n    var nextIndex = Controller.getNext();\n    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    prev.disabled = prevIndex < 0;\n    next.disabled = nextIndex < 0;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n    emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);\n  }\n\n  return {\n    arrows: arrows,\n    mount: mount,\n    destroy: destroy\n  };\n}\n\nvar INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + \"-interval\";\n\nfunction Autoplay(Splide2, Components2, options) {\n  var _EventInterface7 = EventInterface(Splide2),\n      on = _EventInterface7.on,\n      bind = _EventInterface7.bind,\n      emit = _EventInterface7.emit;\n\n  var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, \">\"), onAnimationFrame);\n  var isPaused = interval.isPaused;\n  var Elements = Components2.Elements,\n      _Components2$Elements4 = Components2.Elements,\n      root = _Components2$Elements4.root,\n      toggle = _Components2$Elements4.toggle;\n  var autoplay = options.autoplay;\n  var hovered;\n  var focused;\n  var stopped = autoplay === \"pause\";\n\n  function mount() {\n    if (autoplay) {\n      listen();\n      toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);\n      stopped || play();\n      update();\n    }\n  }\n\n  function listen() {\n    if (options.pauseOnHover) {\n      bind(root, \"mouseenter mouseleave\", function (e) {\n        hovered = e.type === \"mouseenter\";\n        autoToggle();\n      });\n    }\n\n    if (options.pauseOnFocus) {\n      bind(root, \"focusin focusout\", function (e) {\n        focused = e.type === \"focusin\";\n        autoToggle();\n      });\n    }\n\n    if (toggle) {\n      bind(toggle, \"click\", function () {\n        stopped ? play() : pause(true);\n      });\n    }\n\n    on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);\n    on(EVENT_MOVE, onMove);\n  }\n\n  function play() {\n    if (isPaused() && Components2.Slides.isEnough()) {\n      interval.start(!options.resetProgress);\n      focused = hovered = stopped = false;\n      update();\n      emit(EVENT_AUTOPLAY_PLAY);\n    }\n  }\n\n  function pause(stop) {\n    if (stop === void 0) {\n      stop = true;\n    }\n\n    stopped = !!stop;\n    update();\n\n    if (!isPaused()) {\n      interval.pause();\n      emit(EVENT_AUTOPLAY_PAUSE);\n    }\n  }\n\n  function autoToggle() {\n    if (!stopped) {\n      hovered || focused ? pause(false) : play();\n    }\n  }\n\n  function update() {\n    if (toggle) {\n      toggleClass(toggle, CLASS_ACTIVE, !stopped);\n      setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? \"play\" : \"pause\"]);\n    }\n  }\n\n  function onAnimationFrame(rate) {\n    var bar = Elements.bar;\n    bar && style(bar, \"width\", rate * 100 + \"%\");\n    emit(EVENT_AUTOPLAY_PLAYING, rate);\n  }\n\n  function onMove(index) {\n    var Slide = Components2.Slides.getAt(index);\n    interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);\n  }\n\n  return {\n    mount: mount,\n    destroy: interval.cancel,\n    play: play,\n    pause: pause,\n    isPaused: isPaused\n  };\n}\n\nfunction Cover(Splide2, Components2, options) {\n  var _EventInterface8 = EventInterface(Splide2),\n      on = _EventInterface8.on;\n\n  function mount() {\n    if (options.cover) {\n      on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));\n      on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));\n    }\n  }\n\n  function cover(cover2) {\n    Components2.Slides.forEach(function (Slide) {\n      var img = child(Slide.container || Slide.slide, \"img\");\n\n      if (img && img.src) {\n        toggle(cover2, img, Slide);\n      }\n    });\n  }\n\n  function toggle(cover2, img, Slide) {\n    Slide.style(\"background\", cover2 ? \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\" : \"\", true);\n    display(img, cover2 ? \"none\" : \"\");\n  }\n\n  return {\n    mount: mount,\n    destroy: apply(cover, false)\n  };\n}\n\nvar BOUNCE_DIFF_THRESHOLD = 10;\nvar BOUNCE_DURATION = 600;\nvar FRICTION_FACTOR = 0.6;\nvar BASE_VELOCITY = 1.5;\nvar MIN_DURATION = 800;\n\nfunction Scroll(Splide2, Components2, options) {\n  var _EventInterface9 = EventInterface(Splide2),\n      on = _EventInterface9.on,\n      emit = _EventInterface9.emit;\n\n  var set = Splide2.state.set;\n  var Move = Components2.Move;\n  var getPosition = Move.getPosition,\n      getLimit = Move.getLimit,\n      exceededLimit = Move.exceededLimit,\n      translate = Move.translate;\n  var interval;\n  var callback;\n  var friction = 1;\n\n  function mount() {\n    on(EVENT_MOVE, clear);\n    on([EVENT_UPDATED, EVENT_REFRESH], cancel);\n  }\n\n  function scroll(destination, duration, snap, onScrolled, noConstrain) {\n    var from = getPosition();\n    clear();\n\n    if (snap) {\n      var size = Components2.Layout.sliderSize();\n      var offset = sign(destination) * size * floor(abs(destination) / size) || 0;\n      destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;\n    }\n\n    var noDistance = approximatelyEqual(from, destination, 1);\n    friction = 1;\n    duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);\n    callback = onScrolled;\n    interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);\n    set(SCROLLING);\n    emit(EVENT_SCROLL);\n    interval.start();\n  }\n\n  function onEnd() {\n    set(IDLE);\n    callback && callback();\n    emit(EVENT_SCROLLED);\n  }\n\n  function update(from, to, noConstrain, rate) {\n    var position = getPosition();\n    var target = from + (to - from) * easing(rate);\n    var diff = (target - position) * friction;\n    translate(position + diff);\n\n    if (Splide2.is(SLIDE) && !noConstrain && exceededLimit()) {\n      friction *= FRICTION_FACTOR;\n\n      if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {\n        scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);\n      }\n    }\n  }\n\n  function clear() {\n    if (interval) {\n      interval.cancel();\n    }\n  }\n\n  function cancel() {\n    if (interval && !interval.isPaused()) {\n      clear();\n      onEnd();\n    }\n  }\n\n  function easing(t) {\n    var easingFunc = options.easingFunc;\n    return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);\n  }\n\n  return {\n    mount: mount,\n    destroy: clear,\n    scroll: scroll,\n    cancel: cancel\n  };\n}\n\nvar SCROLL_LISTENER_OPTIONS = {\n  passive: false,\n  capture: true\n};\n\nfunction Drag(Splide2, Components2, options) {\n  var _EventInterface10 = EventInterface(Splide2),\n      on = _EventInterface10.on,\n      emit = _EventInterface10.emit,\n      bind = _EventInterface10.bind,\n      unbind = _EventInterface10.unbind;\n\n  var state = Splide2.state;\n  var Move = Components2.Move,\n      Scroll = Components2.Scroll,\n      Controller = Components2.Controller,\n      track = Components2.Elements.track,\n      reduce = Components2.Media.reduce;\n  var _Components2$Directio2 = Components2.Direction,\n      resolve = _Components2$Directio2.resolve,\n      orient = _Components2$Directio2.orient;\n  var getPosition = Move.getPosition,\n      exceededLimit = Move.exceededLimit;\n  var basePosition;\n  var baseEvent;\n  var prevBaseEvent;\n  var isFree;\n  var dragging;\n  var exceeded = false;\n  var clickPrevented;\n  var disabled;\n  var target;\n\n  function mount() {\n    bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n    bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n    bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);\n    bind(track, \"click\", onClick, {\n      capture: true\n    });\n    bind(track, \"dragstart\", prevent);\n    on([EVENT_MOUNTED, EVENT_UPDATED], init);\n  }\n\n  function init() {\n    var drag = options.drag;\n    disable(!drag);\n    isFree = drag === \"free\";\n  }\n\n  function onPointerDown(e) {\n    clickPrevented = false;\n\n    if (!disabled) {\n      var isTouch = isTouchEvent(e);\n\n      if (isDraggable(e.target) && (isTouch || !e.button)) {\n        if (!Controller.isBusy()) {\n          target = isTouch ? track : window;\n          dragging = state.is([MOVING, SCROLLING]);\n          prevBaseEvent = null;\n          bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);\n          bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);\n          Move.cancel();\n          Scroll.cancel();\n          save(e);\n        } else {\n          prevent(e, true);\n        }\n      }\n    }\n  }\n\n  function onPointerMove(e) {\n    if (!state.is(DRAGGING)) {\n      state.set(DRAGGING);\n      emit(EVENT_DRAG);\n    }\n\n    if (e.cancelable) {\n      if (dragging) {\n        Move.translate(basePosition + constrain(diffCoord(e)));\n        var expired = diffTime(e) > LOG_INTERVAL;\n        var hasExceeded = exceeded !== (exceeded = exceededLimit());\n\n        if (expired || hasExceeded) {\n          save(e);\n        }\n\n        clickPrevented = true;\n        emit(EVENT_DRAGGING);\n        prevent(e);\n      } else if (isSliderDirection(e)) {\n        dragging = shouldStart(e);\n        prevent(e);\n      }\n    }\n  }\n\n  function onPointerUp(e) {\n    if (state.is(DRAGGING)) {\n      state.set(IDLE);\n      emit(EVENT_DRAGGED);\n    }\n\n    if (dragging) {\n      move(e);\n      prevent(e);\n    }\n\n    unbind(target, POINTER_MOVE_EVENTS, onPointerMove);\n    unbind(target, POINTER_UP_EVENTS, onPointerUp);\n    dragging = false;\n  }\n\n  function onClick(e) {\n    if (!disabled && clickPrevented) {\n      prevent(e, true);\n    }\n  }\n\n  function save(e) {\n    prevBaseEvent = baseEvent;\n    baseEvent = e;\n    basePosition = getPosition();\n  }\n\n  function move(e) {\n    var velocity = computeVelocity(e);\n    var destination = computeDestination(velocity);\n    var rewind = options.rewind && options.rewindByDrag;\n    reduce(false);\n\n    if (isFree) {\n      Controller.scroll(destination, 0, options.snap);\n    } else if (Splide2.is(FADE)) {\n      Controller.go(orient(sign(velocity)) < 0 ? rewind ? \"<\" : \"-\" : rewind ? \">\" : \"+\");\n    } else if (Splide2.is(SLIDE) && exceeded && rewind) {\n      Controller.go(exceededLimit(true) ? \">\" : \"<\");\n    } else {\n      Controller.go(Controller.toDest(destination), true);\n    }\n\n    reduce(true);\n  }\n\n  function shouldStart(e) {\n    var thresholds = options.dragMinThreshold;\n    var isObj = isObject(thresholds);\n    var mouse = isObj && thresholds.mouse || 0;\n    var touch = (isObj ? thresholds.touch : +thresholds) || 10;\n    return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);\n  }\n\n  function isSliderDirection(e) {\n    return abs(diffCoord(e)) > abs(diffCoord(e, true));\n  }\n\n  function computeVelocity(e) {\n    if (Splide2.is(LOOP) || !exceeded) {\n      var time = diffTime(e);\n\n      if (time && time < LOG_INTERVAL) {\n        return diffCoord(e) / time;\n      }\n    }\n\n    return 0;\n  }\n\n  function computeDestination(velocity) {\n    return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));\n  }\n\n  function diffCoord(e, orthogonal) {\n    return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);\n  }\n\n  function diffTime(e) {\n    return timeOf(e) - timeOf(getBaseEvent(e));\n  }\n\n  function getBaseEvent(e) {\n    return baseEvent === e && prevBaseEvent || baseEvent;\n  }\n\n  function coordOf(e, orthogonal) {\n    return (isTouchEvent(e) ? e.changedTouches[0] : e)[\"page\" + resolve(orthogonal ? \"Y\" : \"X\")];\n  }\n\n  function constrain(diff) {\n    return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);\n  }\n\n  function isDraggable(target2) {\n    var noDrag = options.noDrag;\n    return !matches(target2, \".\" + CLASS_PAGINATION_PAGE + \", .\" + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));\n  }\n\n  function isTouchEvent(e) {\n    return typeof TouchEvent !== \"undefined\" && e instanceof TouchEvent;\n  }\n\n  function isDragging() {\n    return dragging;\n  }\n\n  function disable(value) {\n    disabled = value;\n  }\n\n  return {\n    mount: mount,\n    disable: disable,\n    isDragging: isDragging\n  };\n}\n\nvar NORMALIZATION_MAP = {\n  Spacebar: \" \",\n  Right: ARROW_RIGHT,\n  Left: ARROW_LEFT,\n  Up: ARROW_UP,\n  Down: ARROW_DOWN\n};\n\nfunction normalizeKey(key) {\n  key = isString(key) ? key : key.key;\n  return NORMALIZATION_MAP[key] || key;\n}\n\nvar KEYBOARD_EVENT = \"keydown\";\n\nfunction Keyboard(Splide2, Components2, options) {\n  var _EventInterface11 = EventInterface(Splide2),\n      on = _EventInterface11.on,\n      bind = _EventInterface11.bind,\n      unbind = _EventInterface11.unbind;\n\n  var root = Splide2.root;\n  var resolve = Components2.Direction.resolve;\n  var target;\n  var disabled;\n\n  function mount() {\n    init();\n    on(EVENT_UPDATED, destroy);\n    on(EVENT_UPDATED, init);\n    on(EVENT_MOVE, onMove);\n  }\n\n  function init() {\n    var keyboard = options.keyboard;\n\n    if (keyboard) {\n      target = keyboard === \"global\" ? window : root;\n      bind(target, KEYBOARD_EVENT, onKeydown);\n    }\n  }\n\n  function destroy() {\n    unbind(target, KEYBOARD_EVENT);\n  }\n\n  function disable(value) {\n    disabled = value;\n  }\n\n  function onMove() {\n    var _disabled = disabled;\n    disabled = true;\n    nextTick(function () {\n      disabled = _disabled;\n    });\n  }\n\n  function onKeydown(e) {\n    if (!disabled) {\n      var key = normalizeKey(e);\n\n      if (key === resolve(ARROW_LEFT)) {\n        Splide2.go(\"<\");\n      } else if (key === resolve(ARROW_RIGHT)) {\n        Splide2.go(\">\");\n      }\n    }\n  }\n\n  return {\n    mount: mount,\n    destroy: destroy,\n    disable: disable\n  };\n}\n\nvar SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + \"-lazy\";\nvar SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + \"-srcset\";\nvar IMAGE_SELECTOR = \"[\" + SRC_DATA_ATTRIBUTE + \"], [\" + SRCSET_DATA_ATTRIBUTE + \"]\";\n\nfunction LazyLoad(Splide2, Components2, options) {\n  var _EventInterface12 = EventInterface(Splide2),\n      on = _EventInterface12.on,\n      off = _EventInterface12.off,\n      bind = _EventInterface12.bind,\n      emit = _EventInterface12.emit;\n\n  var isSequential = options.lazyLoad === \"sequential\";\n  var events = [EVENT_MOUNTED, EVENT_REFRESH, EVENT_MOVED, EVENT_SCROLLED];\n  var entries = [];\n\n  function mount() {\n    if (options.lazyLoad) {\n      init();\n      on(EVENT_REFRESH, init);\n      isSequential || on(events, observe);\n    }\n  }\n\n  function init() {\n    empty(entries);\n    Components2.Slides.forEach(function (Slide) {\n      queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function (img) {\n        var src = getAttribute(img, SRC_DATA_ATTRIBUTE);\n        var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);\n\n        if (src !== img.src || srcset !== img.srcset) {\n          var className = options.classes.spinner;\n          var parent = img.parentElement;\n          var spinner = child(parent, \".\" + className) || create(\"span\", className, parent);\n          entries.push([img, Slide, spinner]);\n          img.src || display(img, \"none\");\n        }\n      });\n    });\n    isSequential && loadNext();\n  }\n\n  function observe() {\n    entries = entries.filter(function (data) {\n      var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;\n      return data[1].isWithin(Splide2.index, distance) ? load(data) : true;\n    });\n    entries.length || off(events);\n  }\n\n  function load(data) {\n    var img = data[0];\n    addClass(data[1].slide, CLASS_LOADING);\n    bind(img, \"load error\", apply(onLoad, data));\n    setAttribute(img, \"src\", getAttribute(img, SRC_DATA_ATTRIBUTE));\n    setAttribute(img, \"srcset\", getAttribute(img, SRCSET_DATA_ATTRIBUTE));\n    removeAttribute(img, SRC_DATA_ATTRIBUTE);\n    removeAttribute(img, SRCSET_DATA_ATTRIBUTE);\n  }\n\n  function onLoad(data, e) {\n    var img = data[0],\n        Slide = data[1];\n    removeClass(Slide.slide, CLASS_LOADING);\n\n    if (e.type !== \"error\") {\n      remove(data[2]);\n      display(img, \"\");\n      emit(EVENT_LAZYLOAD_LOADED, img, Slide);\n      emit(EVENT_RESIZE);\n    }\n\n    isSequential && loadNext();\n  }\n\n  function loadNext() {\n    entries.length && load(entries.shift());\n  }\n\n  return {\n    mount: mount,\n    destroy: apply(empty, entries)\n  };\n}\n\nfunction Pagination(Splide2, Components2, options) {\n  var event = EventInterface(Splide2);\n  var on = event.on,\n      emit = event.emit,\n      bind = event.bind;\n  var Slides = Components2.Slides,\n      Elements = Components2.Elements,\n      Controller = Components2.Controller;\n  var hasFocus = Controller.hasFocus,\n      getIndex = Controller.getIndex,\n      go = Controller.go;\n  var resolve = Components2.Direction.resolve;\n  var items = [];\n  var list;\n  var paginationClasses;\n\n  function mount() {\n    destroy();\n    on([EVENT_UPDATED, EVENT_REFRESH], mount);\n\n    if (options.pagination && Slides.isEnough()) {\n      on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);\n      createPagination();\n      update();\n      emit(EVENT_PAGINATION_MOUNTED, {\n        list: list,\n        items: items\n      }, getAt(Splide2.index));\n    }\n  }\n\n  function destroy() {\n    if (list) {\n      remove(Elements.pagination ? slice(list.children) : list);\n      removeClass(list, paginationClasses);\n      empty(items);\n      list = null;\n    }\n\n    event.destroy();\n  }\n\n  function createPagination() {\n    var length = Splide2.length;\n    var classes = options.classes,\n        i18n = options.i18n,\n        perPage = options.perPage;\n    var max = hasFocus() ? length : ceil(length / perPage);\n    list = Elements.pagination || create(\"ul\", classes.pagination, Elements.track.parentElement);\n    addClass(list, paginationClasses = CLASS_PAGINATION + \"--\" + getDirection());\n    setAttribute(list, ROLE, \"tablist\");\n    setAttribute(list, ARIA_LABEL, i18n.select);\n    setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? \"vertical\" : \"\");\n\n    for (var i = 0; i < max; i++) {\n      var li = create(\"li\", null, list);\n      var button = create(\"button\", {\n        class: classes.page,\n        type: \"button\"\n      }, li);\n      var controls = Slides.getIn(i).map(function (Slide) {\n        return Slide.slide.id;\n      });\n      var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;\n      bind(button, \"click\", apply(onClick, i));\n\n      if (options.paginationKeyboard) {\n        bind(button, \"keydown\", apply(onKeydown, i));\n      }\n\n      setAttribute(li, ROLE, \"presentation\");\n      setAttribute(button, ROLE, \"tab\");\n      setAttribute(button, ARIA_CONTROLS, controls.join(\" \"));\n      setAttribute(button, ARIA_LABEL, format(text, i + 1));\n      setAttribute(button, TAB_INDEX, -1);\n      items.push({\n        li: li,\n        button: button,\n        page: i\n      });\n    }\n  }\n\n  function onClick(page) {\n    go(\">\" + page, true);\n  }\n\n  function onKeydown(page, e) {\n    var length = items.length;\n    var key = normalizeKey(e);\n    var dir = getDirection();\n    var nextPage = -1;\n\n    if (key === resolve(ARROW_RIGHT, false, dir)) {\n      nextPage = ++page % length;\n    } else if (key === resolve(ARROW_LEFT, false, dir)) {\n      nextPage = (--page + length) % length;\n    } else if (key === \"Home\") {\n      nextPage = 0;\n    } else if (key === \"End\") {\n      nextPage = length - 1;\n    }\n\n    var item = items[nextPage];\n\n    if (item) {\n      focus(item.button);\n      go(\">\" + nextPage);\n      prevent(e, true);\n    }\n  }\n\n  function getDirection() {\n    return options.paginationDirection || options.direction;\n  }\n\n  function getAt(index) {\n    return items[Controller.toPage(index)];\n  }\n\n  function update() {\n    var prev = getAt(getIndex(true));\n    var curr = getAt(getIndex());\n\n    if (prev) {\n      var button = prev.button;\n      removeClass(button, CLASS_ACTIVE);\n      removeAttribute(button, ARIA_SELECTED);\n      setAttribute(button, TAB_INDEX, -1);\n    }\n\n    if (curr) {\n      var _button = curr.button;\n      addClass(_button, CLASS_ACTIVE);\n      setAttribute(_button, ARIA_SELECTED, true);\n      setAttribute(_button, TAB_INDEX, \"\");\n    }\n\n    emit(EVENT_PAGINATION_UPDATED, {\n      list: list,\n      items: items\n    }, prev, curr);\n  }\n\n  return {\n    items: items,\n    mount: mount,\n    destroy: destroy,\n    getAt: getAt,\n    update: update\n  };\n}\n\nvar TRIGGER_KEYS = [\" \", \"Enter\"];\n\nfunction Sync(Splide2, Components2, options) {\n  var isNavigation = options.isNavigation,\n      slideFocus = options.slideFocus;\n  var events = [];\n\n  function setup() {\n    Splide2.options = {\n      slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus\n    };\n  }\n\n  function mount() {\n    Splide2.splides.forEach(function (target) {\n      if (!target.isParent) {\n        sync(Splide2, target.splide);\n        sync(target.splide, Splide2);\n      }\n    });\n\n    if (isNavigation) {\n      navigate();\n    }\n  }\n\n  function destroy() {\n    events.forEach(function (event) {\n      event.destroy();\n    });\n    empty(events);\n  }\n\n  function remount() {\n    destroy();\n    mount();\n  }\n\n  function sync(splide, target) {\n    var event = EventInterface(splide);\n    event.on(EVENT_MOVE, function (index, prev, dest) {\n      target.go(target.is(LOOP) ? dest : index);\n    });\n    events.push(event);\n  }\n\n  function navigate() {\n    var event = EventInterface(Splide2);\n    var on = event.on;\n    on(EVENT_CLICK, onClick);\n    on(EVENT_SLIDE_KEYDOWN, onKeydown);\n    on([EVENT_MOUNTED, EVENT_UPDATED], update);\n    events.push(event);\n    event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);\n  }\n\n  function update() {\n    setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? \"vertical\" : \"\");\n  }\n\n  function onClick(Slide) {\n    Splide2.go(Slide.index);\n  }\n\n  function onKeydown(Slide, e) {\n    if (includes(TRIGGER_KEYS, normalizeKey(e))) {\n      onClick(Slide);\n      prevent(e);\n    }\n  }\n\n  return {\n    setup: setup,\n    mount: mount,\n    destroy: destroy,\n    remount: remount\n  };\n}\n\nfunction Wheel(Splide2, Components2, options) {\n  var _EventInterface13 = EventInterface(Splide2),\n      bind = _EventInterface13.bind;\n\n  var lastTime = 0;\n\n  function mount() {\n    if (options.wheel) {\n      bind(Components2.Elements.track, \"wheel\", onWheel, SCROLL_LISTENER_OPTIONS);\n    }\n  }\n\n  function onWheel(e) {\n    if (e.cancelable) {\n      var deltaY = e.deltaY;\n      var backwards = deltaY < 0;\n      var timeStamp = timeOf(e);\n\n      var _min = options.wheelMinThreshold || 0;\n\n      var sleep = options.wheelSleep || 0;\n\n      if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {\n        Splide2.go(backwards ? \"<\" : \">\");\n        lastTime = timeStamp;\n      }\n\n      shouldPrevent(backwards) && prevent(e);\n    }\n  }\n\n  function shouldPrevent(backwards) {\n    return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;\n  }\n\n  return {\n    mount: mount\n  };\n}\n\nvar SR_REMOVAL_DELAY = 90;\n\nfunction Live(Splide2, Components2, options) {\n  var _EventInterface14 = EventInterface(Splide2),\n      on = _EventInterface14.on;\n\n  var track = Components2.Elements.track;\n  var enabled = options.live && !options.isNavigation;\n  var sr = create(\"span\", CLASS_SR);\n  var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));\n\n  function mount() {\n    if (enabled) {\n      disable(!Components2.Autoplay.isPaused());\n      setAttribute(track, ARIA_ATOMIC, true);\n      sr.textContent = \"\\u2026\";\n      on(EVENT_AUTOPLAY_PLAY, apply(disable, true));\n      on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));\n      on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));\n    }\n  }\n\n  function toggle(active) {\n    setAttribute(track, ARIA_BUSY, active);\n\n    if (active) {\n      append(track, sr);\n      interval.start();\n    } else {\n      remove(sr);\n    }\n  }\n\n  function destroy() {\n    removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);\n    remove(sr);\n  }\n\n  function disable(disabled) {\n    if (enabled) {\n      setAttribute(track, ARIA_LIVE, disabled ? \"off\" : \"polite\");\n    }\n  }\n\n  return {\n    mount: mount,\n    disable: disable,\n    destroy: destroy\n  };\n}\n\nvar ComponentConstructors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Media: Media,\n  Direction: Direction,\n  Elements: Elements,\n  Slides: Slides,\n  Layout: Layout,\n  Clones: Clones,\n  Move: Move,\n  Controller: Controller,\n  Arrows: Arrows,\n  Autoplay: Autoplay,\n  Cover: Cover,\n  Scroll: Scroll,\n  Drag: Drag,\n  Keyboard: Keyboard,\n  LazyLoad: LazyLoad,\n  Pagination: Pagination,\n  Sync: Sync,\n  Wheel: Wheel,\n  Live: Live\n});\nvar I18N = {\n  prev: \"Previous slide\",\n  next: \"Next slide\",\n  first: \"Go to first slide\",\n  last: \"Go to last slide\",\n  slideX: \"Go to slide %s\",\n  pageX: \"Go to page %s\",\n  play: \"Start autoplay\",\n  pause: \"Pause autoplay\",\n  carousel: \"carousel\",\n  slide: \"slide\",\n  select: \"Select a slide to show\",\n  slideLabel: \"%s of %s\"\n};\nvar DEFAULTS = {\n  type: \"slide\",\n  role: \"region\",\n  speed: 400,\n  perPage: 1,\n  cloneStatus: true,\n  arrows: true,\n  pagination: true,\n  paginationKeyboard: true,\n  interval: 5e3,\n  pauseOnHover: true,\n  pauseOnFocus: true,\n  resetProgress: true,\n  easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n  drag: true,\n  direction: \"ltr\",\n  trimSpace: true,\n  focusableNodes: \"a, button, textarea, input, select, iframe\",\n  live: true,\n  classes: CLASSES,\n  i18n: I18N,\n  reducedMotion: {\n    speed: 0,\n    rewindSpeed: 0,\n    autoplay: \"pause\"\n  }\n};\n\nfunction Fade(Splide2, Components2, options) {\n  var _EventInterface15 = EventInterface(Splide2),\n      on = _EventInterface15.on;\n\n  function mount() {\n    on([EVENT_MOUNTED, EVENT_REFRESH], function () {\n      nextTick(function () {\n        Components2.Slides.style(\"transition\", \"opacity \" + options.speed + \"ms \" + options.easing);\n      });\n    });\n  }\n\n  function start(index, done) {\n    var track = Components2.Elements.track;\n    style(track, \"height\", unit(rect(track).height));\n    nextTick(function () {\n      done();\n      style(track, \"height\", \"\");\n    });\n  }\n\n  return {\n    mount: mount,\n    start: start,\n    cancel: noop\n  };\n}\n\nfunction Slide(Splide2, Components2, options) {\n  var _EventInterface16 = EventInterface(Splide2),\n      bind = _EventInterface16.bind;\n\n  var Move = Components2.Move,\n      Controller = Components2.Controller,\n      Scroll = Components2.Scroll;\n  var list = Components2.Elements.list;\n  var transition = apply(style, list, \"transition\");\n  var endCallback;\n\n  function mount() {\n    bind(list, \"transitionend\", function (e) {\n      if (e.target === list && endCallback) {\n        cancel();\n        endCallback();\n      }\n    });\n  }\n\n  function start(index, done) {\n    var destination = Move.toPosition(index, true);\n    var position = Move.getPosition();\n    var speed = getSpeed(index);\n\n    if (abs(destination - position) >= 1 && speed >= 1) {\n      if (options.useScroll) {\n        Scroll.scroll(destination, speed, false, done);\n      } else {\n        transition(\"transform \" + speed + \"ms \" + options.easing);\n        Move.translate(destination, true);\n        endCallback = done;\n      }\n    } else {\n      Move.jump(index);\n      done();\n    }\n  }\n\n  function cancel() {\n    transition(\"\");\n    Scroll.cancel();\n  }\n\n  function getSpeed(index) {\n    var rewindSpeed = options.rewindSpeed;\n\n    if (Splide2.is(SLIDE) && rewindSpeed) {\n      var prev = Controller.getIndex(true);\n      var end = Controller.getEnd();\n\n      if (prev === 0 && index >= end || prev >= end && index === 0) {\n        return rewindSpeed;\n      }\n    }\n\n    return options.speed;\n  }\n\n  return {\n    mount: mount,\n    start: start,\n    cancel: cancel\n  };\n}\n\nvar _Splide = /*#__PURE__*/function () {\n  function _Splide(target, options) {\n    this.event = EventInterface();\n    this.Components = {};\n    this.state = State(CREATED);\n    this.splides = [];\n    this._o = {};\n    this._E = {};\n    var root = isString(target) ? query(document, target) : target;\n    assert(root, root + \" is invalid.\");\n    this.root = root;\n    options = merge({\n      label: getAttribute(root, ARIA_LABEL) || \"\",\n      labelledby: getAttribute(root, ARIA_LABELLEDBY) || \"\"\n    }, DEFAULTS, _Splide.defaults, options || {});\n\n    try {\n      merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));\n    } catch (e) {\n      assert(false, \"Invalid JSON\");\n    }\n\n    this._o = Object.create(merge({}, options));\n  }\n\n  var _proto = _Splide.prototype;\n\n  _proto.mount = function mount(Extensions, Transition) {\n    var _this = this;\n\n    var state = this.state,\n        Components2 = this.Components;\n    assert(state.is([CREATED, DESTROYED]), \"Already mounted!\");\n    state.set(CREATED);\n    this._C = Components2;\n    this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);\n    this._E = Extensions || this._E;\n    var Constructors = assign({}, ComponentConstructors, this._E, {\n      Transition: this._T\n    });\n    forOwn(Constructors, function (Component, key) {\n      var component = Component(_this, Components2, _this._o);\n      Components2[key] = component;\n      component.setup && component.setup();\n    });\n    forOwn(Components2, function (component) {\n      component.mount && component.mount();\n    });\n    this.emit(EVENT_MOUNTED);\n    addClass(this.root, CLASS_INITIALIZED);\n    state.set(IDLE);\n    this.emit(EVENT_READY);\n    return this;\n  };\n\n  _proto.sync = function sync(splide) {\n    this.splides.push({\n      splide: splide\n    });\n    splide.splides.push({\n      splide: this,\n      isParent: true\n    });\n\n    if (this.state.is(IDLE)) {\n      this._C.Sync.remount();\n\n      splide.Components.Sync.remount();\n    }\n\n    return this;\n  };\n\n  _proto.go = function go(control) {\n    this._C.Controller.go(control);\n\n    return this;\n  };\n\n  _proto.on = function on(events, callback) {\n    this.event.on(events, callback);\n    return this;\n  };\n\n  _proto.off = function off(events) {\n    this.event.off(events);\n    return this;\n  };\n\n  _proto.emit = function emit(event) {\n    var _this$event;\n\n    (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));\n\n    return this;\n  };\n\n  _proto.add = function add(slides, index) {\n    this._C.Slides.add(slides, index);\n\n    return this;\n  };\n\n  _proto.remove = function remove(matcher) {\n    this._C.Slides.remove(matcher);\n\n    return this;\n  };\n\n  _proto.is = function is(type) {\n    return this._o.type === type;\n  };\n\n  _proto.refresh = function refresh() {\n    this.emit(EVENT_REFRESH);\n    return this;\n  };\n\n  _proto.destroy = function destroy(completely) {\n    if (completely === void 0) {\n      completely = true;\n    }\n\n    var event = this.event,\n        state = this.state;\n\n    if (state.is(CREATED)) {\n      EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));\n    } else {\n      forOwn(this._C, function (component) {\n        component.destroy && component.destroy(completely);\n      }, true);\n      event.emit(EVENT_DESTROY);\n      event.destroy();\n      completely && empty(this.splides);\n      state.set(DESTROYED);\n    }\n\n    return this;\n  };\n\n  _createClass(_Splide, [{\n    key: \"options\",\n    get: function get() {\n      return this._o;\n    },\n    set: function set(options) {\n      this._C.Media.set(options, true);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._C.Slides.getLength(true);\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this._C.Controller.getIndex();\n    }\n  }]);\n\n  return _Splide;\n}();\n\nvar Splide = _Splide;\nSplide.defaults = {};\nSplide.STATES = STATES;\nvar CLASS_RENDERED = \"is-rendered\";\nvar RENDERER_DEFAULT_CONFIG = {\n  listTag: \"ul\",\n  slideTag: \"li\"\n};\n\nvar Style = /*#__PURE__*/function () {\n  function Style(id, options) {\n    this.styles = {};\n    this.id = id;\n    this.options = options;\n  }\n\n  var _proto2 = Style.prototype;\n\n  _proto2.rule = function rule(selector, prop, value, breakpoint) {\n    breakpoint = breakpoint || \"default\";\n    var selectors = this.styles[breakpoint] = this.styles[breakpoint] || {};\n    var styles = selectors[selector] = selectors[selector] || {};\n    styles[prop] = value;\n  };\n\n  _proto2.build = function build() {\n    var _this2 = this;\n\n    var css = \"\";\n\n    if (this.styles.default) {\n      css += this.buildSelectors(this.styles.default);\n    }\n\n    Object.keys(this.styles).sort(function (n, m) {\n      return _this2.options.mediaQuery === \"min\" ? +n - +m : +m - +n;\n    }).forEach(function (breakpoint) {\n      if (breakpoint !== \"default\") {\n        css += \"@media screen and (max-width: \" + breakpoint + \"px) {\";\n        css += _this2.buildSelectors(_this2.styles[breakpoint]);\n        css += \"}\";\n      }\n    });\n    return css;\n  };\n\n  _proto2.buildSelectors = function buildSelectors(selectors) {\n    var _this3 = this;\n\n    var css = \"\";\n    forOwn(selectors, function (styles, selector) {\n      selector = (\"#\" + _this3.id + \" \" + selector).trim();\n      css += selector + \" {\";\n      forOwn(styles, function (value, prop) {\n        if (value || value === 0) {\n          css += prop + \": \" + value + \";\";\n        }\n      });\n      css += \"}\";\n    });\n    return css;\n  };\n\n  return Style;\n}();\n\nvar SplideRenderer = /*#__PURE__*/function () {\n  function SplideRenderer(contents, options, config, defaults) {\n    this.slides = [];\n    this.options = {};\n    this.breakpoints = [];\n    merge(DEFAULTS, defaults || {});\n    merge(merge(this.options, DEFAULTS), options || {});\n    this.contents = contents;\n    this.config = assign({}, RENDERER_DEFAULT_CONFIG, config || {});\n    this.id = this.config.id || uniqueId(\"splide\");\n    this.Style = new Style(this.id, this.options);\n    this.Direction = Direction(null, null, this.options);\n    assert(this.contents.length, \"Provide at least 1 content.\");\n    this.init();\n  }\n\n  SplideRenderer.clean = function clean(splide) {\n    var _EventInterface17 = EventInterface(splide),\n        on = _EventInterface17.on;\n\n    var root = splide.root;\n    var clones = queryAll(root, \".\" + CLASS_CLONE);\n    on(EVENT_MOUNTED, function () {\n      remove(child(root, \"style\"));\n    });\n    remove(clones);\n  };\n\n  var _proto3 = SplideRenderer.prototype;\n\n  _proto3.init = function init() {\n    this.parseBreakpoints();\n    this.initSlides();\n    this.registerRootStyles();\n    this.registerTrackStyles();\n    this.registerSlideStyles();\n    this.registerListStyles();\n  };\n\n  _proto3.initSlides = function initSlides() {\n    var _this4 = this;\n\n    push(this.slides, this.contents.map(function (content, index) {\n      content = isString(content) ? {\n        html: content\n      } : content;\n      content.styles = content.styles || {};\n      content.attrs = content.attrs || {};\n\n      _this4.cover(content);\n\n      var classes = _this4.options.classes.slide + \" \" + (index === 0 ? CLASS_ACTIVE : \"\");\n      assign(content.attrs, {\n        class: (classes + \" \" + (content.attrs.class || \"\")).trim(),\n        style: _this4.buildStyles(content.styles)\n      });\n      return content;\n    }));\n\n    if (this.isLoop()) {\n      this.generateClones(this.slides);\n    }\n  };\n\n  _proto3.registerRootStyles = function registerRootStyles() {\n    var _this5 = this;\n\n    this.breakpoints.forEach(function (_ref2) {\n      var width = _ref2[0],\n          options = _ref2[1];\n\n      _this5.Style.rule(\" \", \"max-width\", unit(options.width), width);\n    });\n  };\n\n  _proto3.registerTrackStyles = function registerTrackStyles() {\n    var _this6 = this;\n\n    var Style2 = this.Style;\n    var selector = \".\" + CLASS_TRACK;\n    this.breakpoints.forEach(function (_ref3) {\n      var width = _ref3[0],\n          options = _ref3[1];\n      Style2.rule(selector, _this6.resolve(\"paddingLeft\"), _this6.cssPadding(options, false), width);\n      Style2.rule(selector, _this6.resolve(\"paddingRight\"), _this6.cssPadding(options, true), width);\n      Style2.rule(selector, \"height\", _this6.cssTrackHeight(options), width);\n    });\n  };\n\n  _proto3.registerListStyles = function registerListStyles() {\n    var _this7 = this;\n\n    var Style2 = this.Style;\n    var selector = \".\" + CLASS_LIST;\n    this.breakpoints.forEach(function (_ref4) {\n      var width = _ref4[0],\n          options = _ref4[1];\n      Style2.rule(selector, \"transform\", _this7.buildTranslate(options), width);\n\n      if (!_this7.cssSlideHeight(options)) {\n        Style2.rule(selector, \"aspect-ratio\", _this7.cssAspectRatio(options), width);\n      }\n    });\n  };\n\n  _proto3.registerSlideStyles = function registerSlideStyles() {\n    var _this8 = this;\n\n    var Style2 = this.Style;\n    var selector = \".\" + CLASS_SLIDE;\n    this.breakpoints.forEach(function (_ref5) {\n      var width = _ref5[0],\n          options = _ref5[1];\n      Style2.rule(selector, \"width\", _this8.cssSlideWidth(options), width);\n      Style2.rule(selector, \"height\", _this8.cssSlideHeight(options) || \"100%\", width);\n      Style2.rule(selector, _this8.resolve(\"marginRight\"), unit(options.gap) || \"0px\", width);\n      Style2.rule(selector + \" > img\", \"display\", options.cover ? \"none\" : \"inline\", width);\n    });\n  };\n\n  _proto3.buildTranslate = function buildTranslate(options) {\n    var _this$Direction = this.Direction,\n        resolve = _this$Direction.resolve,\n        orient = _this$Direction.orient;\n    var values = [];\n    values.push(this.cssOffsetClones(options));\n    values.push(this.cssOffsetGaps(options));\n\n    if (this.isCenter(options)) {\n      values.push(this.buildCssValue(orient(-50), \"%\"));\n      values.push.apply(values, this.cssOffsetCenter(options));\n    }\n\n    return values.filter(Boolean).map(function (value) {\n      return \"translate\" + resolve(\"X\") + \"(\" + value + \")\";\n    }).join(\" \");\n  };\n\n  _proto3.cssOffsetClones = function cssOffsetClones(options) {\n    var _this$Direction2 = this.Direction,\n        resolve = _this$Direction2.resolve,\n        orient = _this$Direction2.orient;\n    var cloneCount = this.getCloneCount();\n\n    if (this.isFixedWidth(options)) {\n      var _this$parseCssValue = this.parseCssValue(options[resolve(\"fixedWidth\")]),\n          value = _this$parseCssValue.value,\n          unit2 = _this$parseCssValue.unit;\n\n      return this.buildCssValue(orient(value) * cloneCount, unit2);\n    }\n\n    var percent = 100 * cloneCount / options.perPage;\n    return orient(percent) + \"%\";\n  };\n\n  _proto3.cssOffsetCenter = function cssOffsetCenter(options) {\n    var _this$Direction3 = this.Direction,\n        resolve = _this$Direction3.resolve,\n        orient = _this$Direction3.orient;\n\n    if (this.isFixedWidth(options)) {\n      var _this$parseCssValue2 = this.parseCssValue(options[resolve(\"fixedWidth\")]),\n          value = _this$parseCssValue2.value,\n          unit2 = _this$parseCssValue2.unit;\n\n      return [this.buildCssValue(orient(value / 2), unit2)];\n    }\n\n    var values = [];\n    var perPage = options.perPage,\n        gap = options.gap;\n    values.push(orient(50 / perPage) + \"%\");\n\n    if (gap) {\n      var _this$parseCssValue3 = this.parseCssValue(gap),\n          _value = _this$parseCssValue3.value,\n          _unit = _this$parseCssValue3.unit;\n\n      var gapOffset = (_value / perPage - _value) / 2;\n      values.push(this.buildCssValue(orient(gapOffset), _unit));\n    }\n\n    return values;\n  };\n\n  _proto3.cssOffsetGaps = function cssOffsetGaps(options) {\n    var cloneCount = this.getCloneCount();\n\n    if (cloneCount && options.gap) {\n      var orient = this.Direction.orient;\n\n      var _this$parseCssValue4 = this.parseCssValue(options.gap),\n          value = _this$parseCssValue4.value,\n          unit2 = _this$parseCssValue4.unit;\n\n      if (this.isFixedWidth(options)) {\n        return this.buildCssValue(orient(value * cloneCount), unit2);\n      }\n\n      var perPage = options.perPage;\n      var gaps = cloneCount / perPage;\n      return this.buildCssValue(orient(gaps * value), unit2);\n    }\n\n    return \"\";\n  };\n\n  _proto3.resolve = function resolve(prop) {\n    return camelToKebab(this.Direction.resolve(prop));\n  };\n\n  _proto3.cssPadding = function cssPadding(options, right) {\n    var padding = options.padding;\n    var prop = this.Direction.resolve(right ? \"right\" : \"left\", true);\n    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n  };\n\n  _proto3.cssTrackHeight = function cssTrackHeight(options) {\n    var height = \"\";\n\n    if (this.isVertical()) {\n      height = this.cssHeight(options);\n      assert(height, '\"height\" is missing.');\n      height = \"calc(\" + height + \" - \" + this.cssPadding(options, false) + \" - \" + this.cssPadding(options, true) + \")\";\n    }\n\n    return height;\n  };\n\n  _proto3.cssHeight = function cssHeight(options) {\n    return unit(options.height);\n  };\n\n  _proto3.cssSlideWidth = function cssSlideWidth(options) {\n    return options.autoWidth ? \"\" : unit(options.fixedWidth) || (this.isVertical() ? \"\" : this.cssSlideSize(options));\n  };\n\n  _proto3.cssSlideHeight = function cssSlideHeight(options) {\n    return unit(options.fixedHeight) || (this.isVertical() ? options.autoHeight ? \"\" : this.cssSlideSize(options) : this.cssHeight(options));\n  };\n\n  _proto3.cssSlideSize = function cssSlideSize(options) {\n    var gap = unit(options.gap);\n    return \"calc((100%\" + (gap && \" + \" + gap) + \")/\" + (options.perPage || 1) + (gap && \" - \" + gap) + \")\";\n  };\n\n  _proto3.cssAspectRatio = function cssAspectRatio(options) {\n    var heightRatio = options.heightRatio;\n    return heightRatio ? \"\" + 1 / heightRatio : \"\";\n  };\n\n  _proto3.buildCssValue = function buildCssValue(value, unit2) {\n    return \"\" + value + unit2;\n  };\n\n  _proto3.parseCssValue = function parseCssValue(value) {\n    if (isString(value)) {\n      var number = parseFloat(value) || 0;\n      var unit2 = value.replace(/\\d*(\\.\\d*)?/, \"\") || \"px\";\n      return {\n        value: number,\n        unit: unit2\n      };\n    }\n\n    return {\n      value: value,\n      unit: \"px\"\n    };\n  };\n\n  _proto3.parseBreakpoints = function parseBreakpoints() {\n    var _this9 = this;\n\n    var breakpoints = this.options.breakpoints;\n    this.breakpoints.push([\"default\", this.options]);\n\n    if (breakpoints) {\n      forOwn(breakpoints, function (options, width) {\n        _this9.breakpoints.push([width, merge(merge({}, _this9.options), options)]);\n      });\n    }\n  };\n\n  _proto3.isFixedWidth = function isFixedWidth(options) {\n    return !!options[this.Direction.resolve(\"fixedWidth\")];\n  };\n\n  _proto3.isLoop = function isLoop() {\n    return this.options.type === LOOP;\n  };\n\n  _proto3.isCenter = function isCenter(options) {\n    if (options.focus === \"center\") {\n      if (this.isLoop()) {\n        return true;\n      }\n\n      if (this.options.type === SLIDE) {\n        return !this.options.trimSpace;\n      }\n    }\n\n    return false;\n  };\n\n  _proto3.isVertical = function isVertical() {\n    return this.options.direction === TTB;\n  };\n\n  _proto3.buildClasses = function buildClasses() {\n    var options = this.options;\n    return [CLASS_ROOT, CLASS_ROOT + \"--\" + options.type, CLASS_ROOT + \"--\" + options.direction, options.drag && CLASS_ROOT + \"--draggable\", options.isNavigation && CLASS_ROOT + \"--nav\", CLASS_ACTIVE, !this.config.hidden && CLASS_RENDERED].filter(Boolean).join(\" \");\n  };\n\n  _proto3.buildAttrs = function buildAttrs(attrs) {\n    var attr = \"\";\n    forOwn(attrs, function (value, key) {\n      attr += value ? \" \" + camelToKebab(key) + \"=\\\"\" + value + \"\\\"\" : \"\";\n    });\n    return attr.trim();\n  };\n\n  _proto3.buildStyles = function buildStyles(styles) {\n    var style = \"\";\n    forOwn(styles, function (value, key) {\n      style += \" \" + camelToKebab(key) + \":\" + value + \";\";\n    });\n    return style.trim();\n  };\n\n  _proto3.renderSlides = function renderSlides() {\n    var _this10 = this;\n\n    var tag = this.config.slideTag;\n    return this.slides.map(function (content) {\n      return \"<\" + tag + \" \" + _this10.buildAttrs(content.attrs) + \">\" + (content.html || \"\") + \"</\" + tag + \">\";\n    }).join(\"\");\n  };\n\n  _proto3.cover = function cover(content) {\n    var styles = content.styles,\n        _content$html = content.html,\n        html = _content$html === void 0 ? \"\" : _content$html;\n\n    if (this.options.cover && !this.options.lazyLoad) {\n      var src = html.match(/<img.*?src\\s*=\\s*(['\"])(.+?)\\1.*?>/);\n\n      if (src && src[2]) {\n        styles.background = \"center/cover no-repeat url('\" + src[2] + \"')\";\n      }\n    }\n  };\n\n  _proto3.generateClones = function generateClones(contents) {\n    var classes = this.options.classes;\n    var count = this.getCloneCount();\n    var slides = contents.slice();\n\n    while (slides.length < count) {\n      push(slides, slides);\n    }\n\n    push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach(function (content, index) {\n      var attrs = assign({}, content.attrs, {\n        class: content.attrs.class + \" \" + classes.clone\n      });\n      var clone = assign({}, content, {\n        attrs: attrs\n      });\n      index < count ? contents.unshift(clone) : contents.push(clone);\n    });\n  };\n\n  _proto3.getCloneCount = function getCloneCount() {\n    if (this.isLoop()) {\n      var options = this.options;\n\n      if (options.clones) {\n        return options.clones;\n      }\n\n      var perPage = max.apply(void 0, this.breakpoints.map(function (_ref6) {\n        var options2 = _ref6[1];\n        return options2.perPage;\n      }));\n      return perPage * ((options.flickMaxPages || 1) + 1);\n    }\n\n    return 0;\n  };\n\n  _proto3.renderArrows = function renderArrows() {\n    var html = \"\";\n    html += \"<div class=\\\"\" + this.options.classes.arrows + \"\\\">\";\n    html += this.renderArrow(true);\n    html += this.renderArrow(false);\n    html += \"</div>\";\n    return html;\n  };\n\n  _proto3.renderArrow = function renderArrow(prev) {\n    var _this$options = this.options,\n        classes = _this$options.classes,\n        i18n = _this$options.i18n;\n    var attrs = {\n      class: classes.arrow + \" \" + (prev ? classes.prev : classes.next),\n      type: \"button\",\n      ariaLabel: prev ? i18n.prev : i18n.next\n    };\n    return \"<button \" + this.buildAttrs(attrs) + \"><svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\" viewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\" width=\\\"\" + SIZE + \"\\\" height=\\\"\" + SIZE + \"\\\"><path d=\\\"\" + (this.options.arrowPath || PATH) + \"\\\" /></svg></button>\";\n  };\n\n  _proto3.html = function html() {\n    var _this$config = this.config,\n        rootClass = _this$config.rootClass,\n        listTag = _this$config.listTag,\n        arrows = _this$config.arrows,\n        beforeTrack = _this$config.beforeTrack,\n        afterTrack = _this$config.afterTrack,\n        slider = _this$config.slider,\n        beforeSlider = _this$config.beforeSlider,\n        afterSlider = _this$config.afterSlider;\n    var html = \"\";\n    html += \"<div id=\\\"\" + this.id + \"\\\" class=\\\"\" + this.buildClasses() + \" \" + (rootClass || \"\") + \"\\\">\";\n    html += \"<style>\" + this.Style.build() + \"</style>\";\n\n    if (slider) {\n      html += beforeSlider || \"\";\n      html += \"<div class=\\\"splide__slider\\\">\";\n    }\n\n    html += beforeTrack || \"\";\n\n    if (arrows) {\n      html += this.renderArrows();\n    }\n\n    html += \"<div class=\\\"splide__track\\\">\";\n    html += \"<\" + listTag + \" class=\\\"splide__list\\\">\";\n    html += this.renderSlides();\n    html += \"</\" + listTag + \">\";\n    html += \"</div>\";\n    html += afterTrack || \"\";\n\n    if (slider) {\n      html += \"</div>\";\n      html += afterSlider || \"\";\n    }\n\n    html += \"</div>\";\n    return html;\n  };\n\n  return SplideRenderer;\n}();\n\nexport { CLASSES, CLASS_ACTIVE, CLASS_ARROW, CLASS_ARROWS, CLASS_ARROW_NEXT, CLASS_ARROW_PREV, CLASS_CLONE, CLASS_CONTAINER, CLASS_FOCUS_IN, CLASS_INITIALIZED, CLASS_LIST, CLASS_LOADING, CLASS_NEXT, CLASS_PAGINATION, CLASS_PAGINATION_PAGE, CLASS_PREV, CLASS_PROGRESS, CLASS_PROGRESS_BAR, CLASS_ROOT, CLASS_SLIDE, CLASS_SPINNER, CLASS_SR, CLASS_TOGGLE, CLASS_TOGGLE_PAUSE, CLASS_TOGGLE_PLAY, CLASS_TRACK, CLASS_VISIBLE, DEFAULTS, EVENT_ACTIVE, EVENT_ARROWS_MOUNTED, EVENT_ARROWS_UPDATED, EVENT_AUTOPLAY_PAUSE, EVENT_AUTOPLAY_PLAY, EVENT_AUTOPLAY_PLAYING, EVENT_CLICK, EVENT_DESTROY, EVENT_DRAG, EVENT_DRAGGED, EVENT_DRAGGING, EVENT_HIDDEN, EVENT_INACTIVE, EVENT_LAZYLOAD_LOADED, EVENT_MOUNTED, EVENT_MOVE, EVENT_MOVED, EVENT_NAVIGATION_MOUNTED, EVENT_PAGINATION_MOUNTED, EVENT_PAGINATION_UPDATED, EVENT_READY, EVENT_REFRESH, EVENT_RESIZE, EVENT_RESIZED, EVENT_SCROLL, EVENT_SCROLLED, EVENT_SHIFTED, EVENT_SLIDE_KEYDOWN, EVENT_UPDATED, EVENT_VISIBLE, EventBinder, EventInterface, FADE, LOOP, LTR, RTL, RequestInterval, SLIDE, STATUS_CLASSES, Splide, SplideRenderer, State, TTB, Throttle, Splide as default };\n","function empty(array) {\n  array.length = 0;\n}\n\nfunction slice(arrayLike, start, end) {\n  return Array.prototype.slice.call(arrayLike, start, end);\n}\n\nfunction find(arrayLike, predicate) {\n  return slice(arrayLike).filter(predicate)[0];\n}\n\nfunction apply(func) {\n  return func.bind(null, ...slice(arguments, 1));\n}\n\nconst nextTick = setTimeout;\n\nconst noop = () => {\n};\n\nfunction raf(func) {\n  return requestAnimationFrame(func);\n}\n\nfunction typeOf(type, subject) {\n  return typeof subject === type;\n}\nfunction isObject(subject) {\n  return !isNull(subject) && typeOf(\"object\", subject);\n}\nconst isArray = Array.isArray;\nconst isFunction = apply(typeOf, \"function\");\nconst isString = apply(typeOf, \"string\");\nconst isUndefined = apply(typeOf, \"undefined\");\nfunction isNull(subject) {\n  return subject === null;\n}\nfunction isHTMLElement(subject) {\n  return subject instanceof HTMLElement;\n}\nfunction isHTMLButtonElement(subject) {\n  return subject instanceof HTMLButtonElement;\n}\n\nfunction toArray(value) {\n  return isArray(value) ? value : [value];\n}\n\nfunction forEach(values, iteratee) {\n  toArray(values).forEach(iteratee);\n}\n\nfunction includes(array, value) {\n  return array.indexOf(value) > -1;\n}\n\nfunction push(array, items) {\n  array.push(...toArray(items));\n  return array;\n}\n\nfunction toggleClass(elm, classes, add) {\n  if (elm) {\n    forEach(classes, (name) => {\n      if (name) {\n        elm.classList[add ? \"add\" : \"remove\"](name);\n      }\n    });\n  }\n}\n\nfunction addClass(elm, classes) {\n  toggleClass(elm, isString(classes) ? classes.split(\" \") : classes, true);\n}\n\nfunction append(parent, children) {\n  forEach(children, parent.appendChild.bind(parent));\n}\n\nfunction before(nodes, ref) {\n  forEach(nodes, (node) => {\n    const parent = (ref || node).parentNode;\n    if (parent) {\n      parent.insertBefore(node, ref);\n    }\n  });\n}\n\nfunction matches(elm, selector) {\n  return isHTMLElement(elm) && (elm[\"msMatchesSelector\"] || elm.matches).call(elm, selector);\n}\n\nfunction children(parent, selector) {\n  const children2 = parent ? slice(parent.children) : [];\n  return selector ? children2.filter((child) => matches(child, selector)) : children2;\n}\n\nfunction child(parent, selector) {\n  return selector ? children(parent, selector)[0] : parent.firstElementChild;\n}\n\nconst ownKeys = Object.keys;\n\nfunction forOwn(object, iteratee, right) {\n  if (object) {\n    let keys = ownKeys(object);\n    keys = right ? keys.reverse() : keys;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key !== \"__proto__\") {\n        if (iteratee(object[key], key) === false) {\n          break;\n        }\n      }\n    }\n  }\n  return object;\n}\n\nfunction assign(object) {\n  slice(arguments, 1).forEach((source) => {\n    forOwn(source, (value, key) => {\n      object[key] = source[key];\n    });\n  });\n  return object;\n}\n\nfunction merge(object) {\n  slice(arguments, 1).forEach((source) => {\n    forOwn(source, (value, key) => {\n      if (isArray(value)) {\n        object[key] = value.slice();\n      } else if (isObject(value)) {\n        object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);\n      } else {\n        object[key] = value;\n      }\n    });\n  });\n  return object;\n}\n\nfunction omit(object, keys) {\n  toArray(keys || ownKeys(object)).forEach((key) => {\n    delete object[key];\n  });\n}\n\nfunction removeAttribute(elms, attrs) {\n  forEach(elms, (elm) => {\n    forEach(attrs, (attr) => {\n      elm && elm.removeAttribute(attr);\n    });\n  });\n}\n\nfunction setAttribute(elms, attrs, value) {\n  if (isObject(attrs)) {\n    forOwn(attrs, (value2, name) => {\n      setAttribute(elms, name, value2);\n    });\n  } else {\n    forEach(elms, (elm) => {\n      isNull(value) || value === \"\" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n    });\n  }\n}\n\nfunction create(tag, attrs, parent) {\n  const elm = document.createElement(tag);\n  if (attrs) {\n    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);\n  }\n  parent && append(parent, elm);\n  return elm;\n}\n\nfunction style(elm, prop, value) {\n  if (isUndefined(value)) {\n    return getComputedStyle(elm)[prop];\n  }\n  if (!isNull(value)) {\n    elm.style[prop] = `${value}`;\n  }\n}\n\nfunction display(elm, display2) {\n  style(elm, \"display\", display2);\n}\n\nfunction focus(elm) {\n  elm[\"setActive\"] && elm[\"setActive\"]() || elm.focus({ preventScroll: true });\n}\n\nfunction getAttribute(elm, attr) {\n  return elm.getAttribute(attr);\n}\n\nfunction hasClass(elm, className) {\n  return elm && elm.classList.contains(className);\n}\n\nfunction rect(target) {\n  return target.getBoundingClientRect();\n}\n\nfunction remove(nodes) {\n  forEach(nodes, (node) => {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n}\n\nfunction measure(parent, value) {\n  if (isString(value)) {\n    const div = create(\"div\", { style: `width: ${value}; position: absolute;` }, parent);\n    value = rect(div).width;\n    remove(div);\n  }\n  return value;\n}\n\nfunction parseHtml(html) {\n  return child(new DOMParser().parseFromString(html, \"text/html\").body);\n}\n\nfunction prevent(e, stopPropagation) {\n  e.preventDefault();\n  if (stopPropagation) {\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n  }\n}\n\nfunction query(parent, selector) {\n  return parent && parent.querySelector(selector);\n}\n\nfunction queryAll(parent, selector) {\n  return selector ? slice(parent.querySelectorAll(selector)) : [];\n}\n\nfunction removeClass(elm, classes) {\n  toggleClass(elm, classes, false);\n}\n\nfunction timeOf(e) {\n  return e.timeStamp;\n}\n\nfunction unit(value) {\n  return isString(value) ? value : value ? `${value}px` : \"\";\n}\n\nconst PROJECT_CODE = \"splide\";\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(`[${PROJECT_CODE}] ${message || \"\"}`);\n  }\n}\n\nfunction error(message) {\n  console.error(`[${PROJECT_CODE}] ${message}`);\n}\n\nconst { min, max, floor, ceil, abs } = Math;\n\nfunction approximatelyEqual(x, y, epsilon) {\n  return abs(x - y) < epsilon;\n}\n\nfunction between(number, minOrMax, maxOrMin, exclusive) {\n  const minimum = min(minOrMax, maxOrMin);\n  const maximum = max(minOrMax, maxOrMin);\n  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;\n}\n\nfunction clamp(number, x, y) {\n  const minimum = min(x, y);\n  const maximum = max(x, y);\n  return min(max(minimum, number), maximum);\n}\n\nfunction sign(x) {\n  return +(x > 0) - +(x < 0);\n}\n\nfunction camelToKebab(string) {\n  return string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nfunction format(string, replacements) {\n  forEach(replacements, (replacement) => {\n    string = string.replace(\"%s\", `${replacement}`);\n  });\n  return string;\n}\n\nfunction pad(number) {\n  return number < 10 ? `0${number}` : `${number}`;\n}\n\nconst ids = {};\nfunction uniqueId(prefix) {\n  return `${prefix}${pad(ids[prefix] = (ids[prefix] || 0) + 1)}`;\n}\n\nexport { abs, addClass, append, apply, approximatelyEqual, assert, assign, before, between, camelToKebab, ceil, child, children, clamp, create, display, empty, error, find, floor, focus, forEach, forOwn, format, getAttribute, hasClass, includes, isArray, isFunction, isHTMLButtonElement, isHTMLElement, isNull, isObject, isString, isUndefined, matches, max, measure, merge, min, nextTick, noop, omit, ownKeys, pad, parseHtml, prevent, push, query, queryAll, raf, rect, remove, removeAttribute, removeClass, setAttribute, sign, slice, style, timeOf, toArray, toggleClass, uniqueId, unit };\n","export const CLASS_VIDEO             = 'splide__video';\r\nexport const CLASS_VIDEO_WRAPPER     = `${ CLASS_VIDEO }__wrapper`;\r\nexport const CLASS_VIDEO_PLAY_BUTTON = `${ CLASS_VIDEO }__play`;\r\nexport const CLASS_PLAYING           = 'is-playing';\r\nexport const CLASS_ERROR             = 'is-error';\r\nexport const CLASS_VIDEO_DISABLED    = 'is-video-disabled';\r\nexport const MODIFIER_HAS_VIDEO      = '--has-video';\r\n\r\n\r\n","import { VideoOptions } from '../types/options';\r\n\r\n\r\n/**\r\n * Default options.\r\n * Some parameters must be explicitly set to `false` for vimeo options.\r\n */\r\nexport const DEFAULTS: VideoOptions = {\r\n  hideControls: false,\r\n  loop        : false,\r\n  mute        : false,\r\n  volume      : 0.2,\r\n};\r\n","export const EVENT_VIDEO_PLAY  = 'video:play';\r\nexport const EVENT_VIDEO_PAUSE = 'video:pause';\r\nexport const EVENT_VIDEO_ENDED = 'video:ended';\r\nexport const EVENT_VIDEO_ERROR = 'video:error';\r\nexport const EVENT_VIDEO_CLICK = 'video:click';\r\n","import { AnyFunction, EventInterface, State } from '@splidejs/splide';\r\nimport { error } from '@splidejs/splide/src/js/utils';\r\nimport {\r\n  ERROR,\r\n  IDLE,\r\n  INITIALIZED,\r\n  INITIALIZING,\r\n  LOADING,\r\n  NOT_INITIALIZED,\r\n  PENDING_PLAY,\r\n  PLAY_REQUEST_ABORTED,\r\n  PLAYING,\r\n} from '../constants/states';\r\nimport { VideoPlayerInterface } from '../types/general';\r\nimport { VideoOptions } from '../types/options';\r\n\r\n\r\n/**\r\n * The abstract class for implementing a video player.\r\n *\r\n * @since 0.5.0\r\n */\r\nexport abstract class AbstractVideoPlayer<T> implements VideoPlayerInterface {\r\n  /**\r\n   * The target element where the player is mounted.\r\n   */\r\n  protected readonly target: HTMLElement;\r\n\r\n  /**\r\n   * The video ID or the URL itself.\r\n   */\r\n  protected videoId: string;\r\n\r\n  /**\r\n   * Video options.\r\n   */\r\n  protected readonly options: VideoOptions;\r\n\r\n  /**\r\n   * The state object.\r\n   */\r\n  protected state = State( NOT_INITIALIZED );\r\n\r\n  /**\r\n   * The EventBus object.\r\n   */\r\n  protected event = EventInterface();\r\n\r\n  /**\r\n   * The player instance.\r\n   */\r\n  protected player: T;\r\n\r\n  /**\r\n   * The VideoPlayer constructor.\r\n   *\r\n   * @param target  - A target element where the player is mounted.\r\n   * @param videoId - A video ID or an URL itself.\r\n   * @param options - Optional. Options.\r\n   */\r\n  protected constructor( target: HTMLElement, videoId: string, options?: VideoOptions ) {\r\n    this.target  = target;\r\n    this.videoId = videoId;\r\n    this.options = options || {};\r\n\r\n    this.onPlay        = this.onPlay.bind( this );\r\n    this.onPause       = this.onPause.bind( this );\r\n    this.onEnded       = this.onEnded.bind( this );\r\n    this.onPlayerReady = this.onPlayerReady.bind( this );\r\n    this.onError       = this.onError.bind( this );\r\n  }\r\n\r\n  /**\r\n   * Creates a player.\r\n   *\r\n   * @param videoId - A video ID.\r\n   *\r\n   * @return A VideoPlayerInterface object.\r\n   */\r\n  protected abstract createPlayer( videoId: string ): T;\r\n\r\n  /**\r\n   * Starts the video.\r\n   */\r\n  protected abstract playVideo(): void;\r\n\r\n  /**\r\n   * Pauses the video.\r\n   */\r\n  protected abstract pauseVideo(): void;\r\n\r\n  /**\r\n   * Attaches a handler to a specified event or events.\r\n   *\r\n   * @param events   - An event or events to attach a handler to.\r\n   * @param callback - A callback function.\r\n   */\r\n  on( events: string | string[], callback: AnyFunction ): void {\r\n    this.event.on( events, callback );\r\n  }\r\n\r\n  /**\r\n   * Requests to play the video.\r\n   */\r\n  play(): void {\r\n    const { state } = this;\r\n\r\n    if ( state.is( ERROR ) ) {\r\n      error( 'Can not play this video.' );\r\n      return;\r\n    }\r\n\r\n    this.event.emit( 'play' );\r\n\r\n    if ( state.is( INITIALIZING ) ) {\r\n      return state.set( PENDING_PLAY );\r\n    }\r\n\r\n    if ( state.is( INITIALIZED ) ) {\r\n      this.player = this.createPlayer( this.videoId );\r\n      return state.set( PENDING_PLAY );\r\n    }\r\n\r\n    if ( state.is( [ PENDING_PLAY, PLAYING ] ) ) {\r\n      return;\r\n    }\r\n\r\n    if ( state.is( IDLE ) ) {\r\n      state.set( LOADING );\r\n      this.playVideo();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Requests to pause the video.\r\n   */\r\n  pause(): void {\r\n    const { state } = this;\r\n\r\n    if ( state.is( ERROR ) ) {\r\n      return;\r\n    }\r\n\r\n    this.event.emit( 'pause' );\r\n\r\n    if ( state.is( PENDING_PLAY ) ) {\r\n      return state.set( INITIALIZING );\r\n    }\r\n\r\n    if ( state.is( LOADING ) ) {\r\n      return state.set( PLAY_REQUEST_ABORTED );\r\n    }\r\n\r\n    if ( state.is( PLAYING ) ) {\r\n      this.pauseVideo();\r\n      this.state.set( IDLE );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the video is paused or not.\r\n   *\r\n   * @return `true` if the video is paused.\r\n   */\r\n  isPaused(): boolean {\r\n    return ! this.state.is( PLAYING );\r\n  }\r\n\r\n  /**\r\n   * Destroys the instance.\r\n   */\r\n  destroy(): void {\r\n    this.event.destroy();\r\n  }\r\n\r\n  /**\r\n   * Called when the player is created.\r\n   */\r\n  protected onPlayerReady(): void {\r\n    const { state } = this;\r\n    const isPending = state.is( PENDING_PLAY );\r\n\r\n    state.set( IDLE );\r\n\r\n    if ( isPending ) {\r\n      this.play();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the video starts.\r\n   */\r\n  protected onPlay(): void {\r\n    const { state } = this;\r\n    const aborted = state.is( PLAY_REQUEST_ABORTED );\r\n\r\n    state.set( PLAYING );\r\n\r\n    if ( aborted ) {\r\n      this.pause();\r\n    } else {\r\n      this.event.emit( 'played' );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the video is paused.\r\n   */\r\n  protected onPause(): void {\r\n    this.state.set( IDLE );\r\n    this.event.emit( 'paused' );\r\n  }\r\n\r\n  /**\r\n   * Called when the video is ended.\r\n   */\r\n  protected onEnded(): void {\r\n    this.state.set( IDLE );\r\n    this.event.emit( 'ended' );\r\n  }\r\n\r\n  /**\r\n   * Called when an error occurs.\r\n   */\r\n  protected onError(): void {\r\n    this.state.set( ERROR );\r\n    this.event.emit( 'error' );\r\n  }\r\n}\r\n","/**\r\n * The player is not initialized.\r\n */\r\nexport const NOT_INITIALIZED = 1;\r\n\r\n/**\r\n * The player is not initialized.\r\n */\r\nexport const INITIALIZING = 2;\r\n\r\n/**\r\n * The player is not initialized.\r\n */\r\nexport const INITIALIZED = 3;\r\n\r\n/**\r\n * Requested to play a video while creating a player.\r\n */\r\nexport const PENDING_PLAY = 4;\r\n\r\n/**\r\n * Ready to play a video.\r\n */\r\nexport const IDLE = 5;\r\n\r\n/**\r\n * Loading a video.\r\n */\r\nexport const LOADING = 6;\r\n\r\n/**\r\n * Play request has been sent to the player, but it is aborted later.\r\n */\r\nexport const PLAY_REQUEST_ABORTED = 7;\r\n\r\n/**\r\n * Now playing a video\r\n */\r\nexport const PLAYING = 8;\r\n\r\n/**\r\n * Any error has been occurred.\r\n */\r\nexport const ERROR = 9;\r\n","import { assign, clamp, create } from '@splidejs/splide/src/js/utils';\r\nimport { AbstractVideoPlayer } from '../../classes/AbstractVideoPlayer';\r\nimport { IDLE, INITIALIZED, PLAY_REQUEST_ABORTED } from '../../constants/states';\r\nimport { VideoOptions } from '../../types/options';\r\n\r\n\r\n/**\r\n * The wrapper class for the HTML video player.\r\n *\r\n * @since 0.5.0\r\n */\r\nexport class HTMLVideoPlayer extends AbstractVideoPlayer<HTMLVideoElement> {\r\n  /**\r\n   * The HTMLVideoPlayer constructor.\r\n   *\r\n   * @param target  - A target element where the player is mounted.\r\n   * @param videoId - A video ID or an URL itself.\r\n   * @param options - Options.\r\n   */\r\n  constructor( target: HTMLElement, videoId: string, options: VideoOptions = {} ) {\r\n    super( target, videoId, options );\r\n    this.state.set( INITIALIZED );\r\n  }\r\n\r\n  /**\r\n   * Creates a player.\r\n   *\r\n   * @param videoId - Optional. A video ID or an URL.\r\n   *\r\n   * @return A Vimeo player instance.\r\n   */\r\n  protected createPlayer( videoId: string ): HTMLVideoElement {\r\n    const { options, options: { playerOptions = {} } } = this;\r\n    const player = create( 'video', { src: videoId }, this.target );\r\n    const on     = player.addEventListener.bind( player );\r\n\r\n    assign( player, {\r\n      controls: ! options.hideControls,\r\n      loop    : options.loop,\r\n      volume  : clamp( options.volume, 0, 1 ),\r\n      muted   : options.mute,\r\n    }, playerOptions.htmlVideo || {} );\r\n\r\n    on( 'play', this.onPlay );\r\n    on( 'pause', this.onPause );\r\n    on( 'ended', this.onEnded );\r\n    on( 'loadeddata', this.onPlayerReady );\r\n    on( 'error', this.onError );\r\n\r\n    return player;\r\n  }\r\n\r\n  /**\r\n   * Starts the video.\r\n   */\r\n  protected playVideo(): void {\r\n    const promise = this.player.play();\r\n    promise && promise.catch( this.onError.bind( this ) );\r\n  }\r\n\r\n  /**\r\n   * Pauses the video.\r\n   */\r\n  protected pauseVideo(): void {\r\n    this.player.pause();\r\n  }\r\n\r\n  /**\r\n   * Called when an error occurs.\r\n   */\r\n  protected onError(): void {\r\n    if ( this.state.is( PLAY_REQUEST_ABORTED ) ) {\r\n      this.state.set( IDLE );\r\n    } else {\r\n      super.onError();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the player.\r\n   */\r\n  destroy(): void {\r\n    super.destroy();\r\n\r\n    const { player } = this;\r\n    const off = player.addEventListener.bind( player );\r\n\r\n    off( 'play', this.onPlay );\r\n    off( 'pause', this.onPause );\r\n    off( 'ended', this.onEnded );\r\n    off( 'loadeddata', this.onPlayerReady );\r\n  }\r\n}\r\n","/*! @vimeo/player v2.17.1 | (c) 2022 Vimeo | MIT License | https://github.com/vimeo/player.js */\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * @module lib/functions\n */\n\n/**\n * Check to see this is a node environment.\n * @type {Boolean}\n */\n\n/* global global */\nvar isNode = typeof global !== 'undefined' && {}.toString.call(global) === '[object global]';\n/**\n * Get the name of the method for a given getter or setter.\n *\n * @param {string} prop The name of the property.\n * @param {string} type Either get or set.\n * @return {string}\n */\n\nfunction getMethodName(prop, type) {\n  if (prop.indexOf(type.toLowerCase()) === 0) {\n    return prop;\n  }\n\n  return \"\".concat(type.toLowerCase()).concat(prop.substr(0, 1).toUpperCase()).concat(prop.substr(1));\n}\n/**\n * Check to see if the object is a DOM Element.\n *\n * @param {*} element The object to check.\n * @return {boolean}\n */\n\nfunction isDomElement(element) {\n  return Boolean(element && element.nodeType === 1 && 'nodeName' in element && element.ownerDocument && element.ownerDocument.defaultView);\n}\n/**\n * Check to see whether the value is a number.\n *\n * @see http://dl.dropboxusercontent.com/u/35146/js/tests/isNumber.html\n * @param {*} value The value to check.\n * @param {boolean} integer Check if the value is an integer.\n * @return {boolean}\n */\n\nfunction isInteger(value) {\n  // eslint-disable-next-line eqeqeq\n  return !isNaN(parseFloat(value)) && isFinite(value) && Math.floor(value) == value;\n}\n/**\n * Check to see if the URL is a Vimeo url.\n *\n * @param {string} url The url string.\n * @return {boolean}\n */\n\nfunction isVimeoUrl(url) {\n  return /^(https?:)?\\/\\/((player|www)\\.)?vimeo\\.com(?=$|\\/)/.test(url);\n}\n/**\n * Check to see if the URL is for a Vimeo embed.\n *\n * @param {string} url The url string.\n * @return {boolean}\n */\n\nfunction isVimeoEmbed(url) {\n  var expr = /^https:\\/\\/player\\.vimeo\\.com\\/video\\/\\d+/;\n  return expr.test(url);\n}\n/**\n * Get the Vimeo URL from an element.\n * The element must have either a data-vimeo-id or data-vimeo-url attribute.\n *\n * @param {object} oEmbedParameters The oEmbed parameters.\n * @return {string}\n */\n\nfunction getVimeoUrl() {\n  var oEmbedParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var id = oEmbedParameters.id;\n  var url = oEmbedParameters.url;\n  var idOrUrl = id || url;\n\n  if (!idOrUrl) {\n    throw new Error('An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.');\n  }\n\n  if (isInteger(idOrUrl)) {\n    return \"https://vimeo.com/\".concat(idOrUrl);\n  }\n\n  if (isVimeoUrl(idOrUrl)) {\n    return idOrUrl.replace('http:', 'https:');\n  }\n\n  if (id) {\n    throw new TypeError(\"\\u201C\".concat(id, \"\\u201D is not a valid video id.\"));\n  }\n\n  throw new TypeError(\"\\u201C\".concat(idOrUrl, \"\\u201D is not a vimeo.com url.\"));\n}\n\nvar arrayIndexOfSupport = typeof Array.prototype.indexOf !== 'undefined';\nvar postMessageSupport = typeof window !== 'undefined' && typeof window.postMessage !== 'undefined';\n\nif (!isNode && (!arrayIndexOfSupport || !postMessageSupport)) {\n  throw new Error('Sorry, the Vimeo Player API is not available in this browser.');\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n/*!\n * weakmap-polyfill v2.0.4 - ECMAScript6 WeakMap polyfill\n * https://github.com/polygonplanet/weakmap-polyfill\n * Copyright (c) 2015-2021 polygonplanet <polygon.planet.aqua@gmail.com>\n * @license MIT\n */\n(function (self) {\n\n  if (self.WeakMap) {\n    return;\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  var hasDefine = Object.defineProperty && function () {\n    try {\n      // Avoid IE8's broken Object.defineProperty\n      return Object.defineProperty({}, 'x', {\n        value: 1\n      }).x === 1;\n    } catch (e) {}\n  }();\n\n  var defineProperty = function (object, name, value) {\n    if (hasDefine) {\n      Object.defineProperty(object, name, {\n        configurable: true,\n        writable: true,\n        value: value\n      });\n    } else {\n      object[name] = value;\n    }\n  };\n\n  self.WeakMap = function () {\n    // ECMA-262 23.3 WeakMap Objects\n    function WeakMap() {\n      if (this === void 0) {\n        throw new TypeError(\"Constructor WeakMap requires 'new'\");\n      }\n\n      defineProperty(this, '_id', genId('_WeakMap')); // ECMA-262 23.3.1.1 WeakMap([iterable])\n\n      if (arguments.length > 0) {\n        // Currently, WeakMap `iterable` argument is not supported\n        throw new TypeError('WeakMap iterable is not supported');\n      }\n    } // ECMA-262 23.3.3.2 WeakMap.prototype.delete(key)\n\n\n    defineProperty(WeakMap.prototype, 'delete', function (key) {\n      checkInstance(this, 'delete');\n\n      if (!isObject(key)) {\n        return false;\n      }\n\n      var entry = key[this._id];\n\n      if (entry && entry[0] === key) {\n        delete key[this._id];\n        return true;\n      }\n\n      return false;\n    }); // ECMA-262 23.3.3.3 WeakMap.prototype.get(key)\n\n    defineProperty(WeakMap.prototype, 'get', function (key) {\n      checkInstance(this, 'get');\n\n      if (!isObject(key)) {\n        return void 0;\n      }\n\n      var entry = key[this._id];\n\n      if (entry && entry[0] === key) {\n        return entry[1];\n      }\n\n      return void 0;\n    }); // ECMA-262 23.3.3.4 WeakMap.prototype.has(key)\n\n    defineProperty(WeakMap.prototype, 'has', function (key) {\n      checkInstance(this, 'has');\n\n      if (!isObject(key)) {\n        return false;\n      }\n\n      var entry = key[this._id];\n\n      if (entry && entry[0] === key) {\n        return true;\n      }\n\n      return false;\n    }); // ECMA-262 23.3.3.5 WeakMap.prototype.set(key, value)\n\n    defineProperty(WeakMap.prototype, 'set', function (key, value) {\n      checkInstance(this, 'set');\n\n      if (!isObject(key)) {\n        throw new TypeError('Invalid value used as weak map key');\n      }\n\n      var entry = key[this._id];\n\n      if (entry && entry[0] === key) {\n        entry[1] = value;\n        return this;\n      }\n\n      defineProperty(key, this._id, [key, value]);\n      return this;\n    });\n\n    function checkInstance(x, methodName) {\n      if (!isObject(x) || !hasOwnProperty.call(x, '_id')) {\n        throw new TypeError(methodName + ' method called on incompatible receiver ' + typeof x);\n      }\n    }\n\n    function genId(prefix) {\n      return prefix + '_' + rand() + '.' + rand();\n    }\n\n    function rand() {\n      return Math.random().toString().substring(2);\n    }\n\n    defineProperty(WeakMap, '_polyfill', true);\n    return WeakMap;\n  }();\n\n  function isObject(x) {\n    return Object(x) === x;\n  }\n})(typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : commonjsGlobal);\n\nvar npo_src = createCommonjsModule(function (module) {\n/*! Native Promise Only\n    v0.8.1 (c) Kyle Simpson\n    MIT License: http://getify.mit-license.org\n*/\n(function UMD(name, context, definition) {\n  // special form of UMD for polyfilling across evironments\n  context[name] = context[name] || definition();\n\n  if ( module.exports) {\n    module.exports = context[name];\n  }\n})(\"Promise\", typeof commonjsGlobal != \"undefined\" ? commonjsGlobal : commonjsGlobal, function DEF() {\n\n  var builtInProp,\n      cycle,\n      scheduling_queue,\n      ToString = Object.prototype.toString,\n      timer = typeof setImmediate != \"undefined\" ? function timer(fn) {\n    return setImmediate(fn);\n  } : setTimeout; // dammit, IE8.\n\n  try {\n    Object.defineProperty({}, \"x\", {});\n\n    builtInProp = function builtInProp(obj, name, val, config) {\n      return Object.defineProperty(obj, name, {\n        value: val,\n        writable: true,\n        configurable: config !== false\n      });\n    };\n  } catch (err) {\n    builtInProp = function builtInProp(obj, name, val) {\n      obj[name] = val;\n      return obj;\n    };\n  } // Note: using a queue instead of array for efficiency\n\n\n  scheduling_queue = function Queue() {\n    var first, last, item;\n\n    function Item(fn, self) {\n      this.fn = fn;\n      this.self = self;\n      this.next = void 0;\n    }\n\n    return {\n      add: function add(fn, self) {\n        item = new Item(fn, self);\n\n        if (last) {\n          last.next = item;\n        } else {\n          first = item;\n        }\n\n        last = item;\n        item = void 0;\n      },\n      drain: function drain() {\n        var f = first;\n        first = last = cycle = void 0;\n\n        while (f) {\n          f.fn.call(f.self);\n          f = f.next;\n        }\n      }\n    };\n  }();\n\n  function schedule(fn, self) {\n    scheduling_queue.add(fn, self);\n\n    if (!cycle) {\n      cycle = timer(scheduling_queue.drain);\n    }\n  } // promise duck typing\n\n\n  function isThenable(o) {\n    var _then,\n        o_type = typeof o;\n\n    if (o != null && (o_type == \"object\" || o_type == \"function\")) {\n      _then = o.then;\n    }\n\n    return typeof _then == \"function\" ? _then : false;\n  }\n\n  function notify() {\n    for (var i = 0; i < this.chain.length; i++) {\n      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);\n    }\n\n    this.chain.length = 0;\n  } // NOTE: This is a separate function to isolate\n  // the `try..catch` so that other code can be\n  // optimized better\n\n\n  function notifyIsolated(self, cb, chain) {\n    var ret, _then;\n\n    try {\n      if (cb === false) {\n        chain.reject(self.msg);\n      } else {\n        if (cb === true) {\n          ret = self.msg;\n        } else {\n          ret = cb.call(void 0, self.msg);\n        }\n\n        if (ret === chain.promise) {\n          chain.reject(TypeError(\"Promise-chain cycle\"));\n        } else if (_then = isThenable(ret)) {\n          _then.call(ret, chain.resolve, chain.reject);\n        } else {\n          chain.resolve(ret);\n        }\n      }\n    } catch (err) {\n      chain.reject(err);\n    }\n  }\n\n  function resolve(msg) {\n    var _then,\n        self = this; // already triggered?\n\n\n    if (self.triggered) {\n      return;\n    }\n\n    self.triggered = true; // unwrap\n\n    if (self.def) {\n      self = self.def;\n    }\n\n    try {\n      if (_then = isThenable(msg)) {\n        schedule(function () {\n          var def_wrapper = new MakeDefWrapper(self);\n\n          try {\n            _then.call(msg, function $resolve$() {\n              resolve.apply(def_wrapper, arguments);\n            }, function $reject$() {\n              reject.apply(def_wrapper, arguments);\n            });\n          } catch (err) {\n            reject.call(def_wrapper, err);\n          }\n        });\n      } else {\n        self.msg = msg;\n        self.state = 1;\n\n        if (self.chain.length > 0) {\n          schedule(notify, self);\n        }\n      }\n    } catch (err) {\n      reject.call(new MakeDefWrapper(self), err);\n    }\n  }\n\n  function reject(msg) {\n    var self = this; // already triggered?\n\n    if (self.triggered) {\n      return;\n    }\n\n    self.triggered = true; // unwrap\n\n    if (self.def) {\n      self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n\n    if (self.chain.length > 0) {\n      schedule(notify, self);\n    }\n  }\n\n  function iteratePromises(Constructor, arr, resolver, rejecter) {\n    for (var idx = 0; idx < arr.length; idx++) {\n      (function IIFE(idx) {\n        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {\n          resolver(idx, msg);\n        }, rejecter);\n      })(idx);\n    }\n  }\n\n  function MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n  }\n\n  function MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n  }\n\n  function Promise(executor) {\n    if (typeof executor != \"function\") {\n      throw TypeError(\"Not a function\");\n    }\n\n    if (this.__NPO__ !== 0) {\n      throw TypeError(\"Not a promise\");\n    } // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n\n\n    this.__NPO__ = 1;\n    var def = new MakeDef(this);\n\n    this[\"then\"] = function then(success, failure) {\n      var o = {\n        success: typeof success == \"function\" ? success : true,\n        failure: typeof failure == \"function\" ? failure : false\n      }; // Note: `then(..)` itself can be borrowed to be used against\n      // a different promise constructor for making the chained promise,\n      // by substituting a different `this` binding.\n\n      o.promise = new this.constructor(function extractChain(resolve, reject) {\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n\n        o.resolve = resolve;\n        o.reject = reject;\n      });\n      def.chain.push(o);\n\n      if (def.state !== 0) {\n        schedule(notify, def);\n      }\n\n      return o.promise;\n    };\n\n    this[\"catch\"] = function $catch$(failure) {\n      return this.then(void 0, failure);\n    };\n\n    try {\n      executor.call(void 0, function publicResolve(msg) {\n        resolve.call(def, msg);\n      }, function publicReject(msg) {\n        reject.call(def, msg);\n      });\n    } catch (err) {\n      reject.call(def, err);\n    }\n  }\n\n  var PromisePrototype = builtInProp({}, \"constructor\", Promise,\n  /*configurable=*/\n  false); // Note: Android 4 cannot use `Object.defineProperty(..)` here\n\n  Promise.prototype = PromisePrototype; // built-in \"brand\" to signal an \"uninitialized\" promise\n\n  builtInProp(PromisePrototype, \"__NPO__\", 0,\n  /*configurable=*/\n  false);\n  builtInProp(Promise, \"resolve\", function Promise$resolve(msg) {\n    var Constructor = this; // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n\n    if (msg && typeof msg == \"object\" && msg.__NPO__ === 1) {\n      return msg;\n    }\n\n    return new Constructor(function executor(resolve, reject) {\n      if (typeof resolve != \"function\" || typeof reject != \"function\") {\n        throw TypeError(\"Not a function\");\n      }\n\n      resolve(msg);\n    });\n  });\n  builtInProp(Promise, \"reject\", function Promise$reject(msg) {\n    return new this(function executor(resolve, reject) {\n      if (typeof resolve != \"function\" || typeof reject != \"function\") {\n        throw TypeError(\"Not a function\");\n      }\n\n      reject(msg);\n    });\n  });\n  builtInProp(Promise, \"all\", function Promise$all(arr) {\n    var Constructor = this; // spec mandated checks\n\n    if (ToString.call(arr) != \"[object Array]\") {\n      return Constructor.reject(TypeError(\"Not an array\"));\n    }\n\n    if (arr.length === 0) {\n      return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve, reject) {\n      if (typeof resolve != \"function\" || typeof reject != \"function\") {\n        throw TypeError(\"Not a function\");\n      }\n\n      var len = arr.length,\n          msgs = Array(len),\n          count = 0;\n      iteratePromises(Constructor, arr, function resolver(idx, msg) {\n        msgs[idx] = msg;\n\n        if (++count === len) {\n          resolve(msgs);\n        }\n      }, reject);\n    });\n  });\n  builtInProp(Promise, \"race\", function Promise$race(arr) {\n    var Constructor = this; // spec mandated checks\n\n    if (ToString.call(arr) != \"[object Array]\") {\n      return Constructor.reject(TypeError(\"Not an array\"));\n    }\n\n    return new Constructor(function executor(resolve, reject) {\n      if (typeof resolve != \"function\" || typeof reject != \"function\") {\n        throw TypeError(\"Not a function\");\n      }\n\n      iteratePromises(Constructor, arr, function resolver(idx, msg) {\n        resolve(msg);\n      }, reject);\n    });\n  });\n  return Promise;\n});\n});\n\n/**\n * @module lib/callbacks\n */\nvar callbackMap = new WeakMap();\n/**\n * Store a callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @param {(function(this:Player, *): void|{resolve: function, reject: function})} callback\n *        The callback to call or an object with resolve and reject functions for a promise.\n * @return {void}\n */\n\nfunction storeCallback(player, name, callback) {\n  var playerCallbacks = callbackMap.get(player.element) || {};\n\n  if (!(name in playerCallbacks)) {\n    playerCallbacks[name] = [];\n  }\n\n  playerCallbacks[name].push(callback);\n  callbackMap.set(player.element, playerCallbacks);\n}\n/**\n * Get the callbacks for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @return {function[]}\n */\n\nfunction getCallbacks(player, name) {\n  var playerCallbacks = callbackMap.get(player.element) || {};\n  return playerCallbacks[name] || [];\n}\n/**\n * Remove a stored callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @param {function} [callback] The specific callback to remove.\n * @return {boolean} Was this the last callback?\n */\n\nfunction removeCallback(player, name, callback) {\n  var playerCallbacks = callbackMap.get(player.element) || {};\n\n  if (!playerCallbacks[name]) {\n    return true;\n  } // If no callback is passed, remove all callbacks for the event\n\n\n  if (!callback) {\n    playerCallbacks[name] = [];\n    callbackMap.set(player.element, playerCallbacks);\n    return true;\n  }\n\n  var index = playerCallbacks[name].indexOf(callback);\n\n  if (index !== -1) {\n    playerCallbacks[name].splice(index, 1);\n  }\n\n  callbackMap.set(player.element, playerCallbacks);\n  return playerCallbacks[name] && playerCallbacks[name].length === 0;\n}\n/**\n * Return the first stored callback for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @return {function} The callback, or false if there were none\n */\n\nfunction shiftCallbacks(player, name) {\n  var playerCallbacks = getCallbacks(player, name);\n\n  if (playerCallbacks.length < 1) {\n    return false;\n  }\n\n  var callback = playerCallbacks.shift();\n  removeCallback(player, name, callback);\n  return callback;\n}\n/**\n * Move callbacks associated with an element to another element.\n *\n * @param {HTMLElement} oldElement The old element.\n * @param {HTMLElement} newElement The new element.\n * @return {void}\n */\n\nfunction swapCallbacks(oldElement, newElement) {\n  var playerCallbacks = callbackMap.get(oldElement);\n  callbackMap.set(newElement, playerCallbacks);\n  callbackMap.delete(oldElement);\n}\n\n/**\n * @module lib/postmessage\n */\n/**\n * Parse a message received from postMessage.\n *\n * @param {*} data The data received from postMessage.\n * @return {object}\n */\n\nfunction parseMessageData(data) {\n  if (typeof data === 'string') {\n    try {\n      data = JSON.parse(data);\n    } catch (error) {\n      // If the message cannot be parsed, throw the error as a warning\n      console.warn(error);\n      return {};\n    }\n  }\n\n  return data;\n}\n/**\n * Post a message to the specified target.\n *\n * @param {Player} player The player object to use.\n * @param {string} method The API method to call.\n * @param {object} params The parameters to send to the player.\n * @return {void}\n */\n\nfunction postMessage(player, method, params) {\n  if (!player.element.contentWindow || !player.element.contentWindow.postMessage) {\n    return;\n  }\n\n  var message = {\n    method: method\n  };\n\n  if (params !== undefined) {\n    message.value = params;\n  } // IE 8 and 9 do not support passing messages, so stringify them\n\n\n  var ieVersion = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\\d+).*$/, '$1'));\n\n  if (ieVersion >= 8 && ieVersion < 10) {\n    message = JSON.stringify(message);\n  }\n\n  player.element.contentWindow.postMessage(message, player.origin);\n}\n/**\n * Parse the data received from a message event.\n *\n * @param {Player} player The player that received the message.\n * @param {(Object|string)} data The message data. Strings will be parsed into JSON.\n * @return {void}\n */\n\nfunction processData(player, data) {\n  data = parseMessageData(data);\n  var callbacks = [];\n  var param;\n\n  if (data.event) {\n    if (data.event === 'error') {\n      var promises = getCallbacks(player, data.data.method);\n      promises.forEach(function (promise) {\n        var error = new Error(data.data.message);\n        error.name = data.data.name;\n        promise.reject(error);\n        removeCallback(player, data.data.method, promise);\n      });\n    }\n\n    callbacks = getCallbacks(player, \"event:\".concat(data.event));\n    param = data.data;\n  } else if (data.method) {\n    var callback = shiftCallbacks(player, data.method);\n\n    if (callback) {\n      callbacks.push(callback);\n      param = data.value;\n    }\n  }\n\n  callbacks.forEach(function (callback) {\n    try {\n      if (typeof callback === 'function') {\n        callback.call(player, param);\n        return;\n      }\n\n      callback.resolve(param);\n    } catch (e) {// empty\n    }\n  });\n}\n\n/**\n * @module lib/embed\n */\nvar oEmbedParameters = ['autopause', 'autoplay', 'background', 'byline', 'color', 'controls', 'dnt', 'height', 'id', 'interactive_params', 'keyboard', 'loop', 'maxheight', 'maxwidth', 'muted', 'playsinline', 'portrait', 'responsive', 'speed', 'texttrack', 'title', 'transparent', 'url', 'width'];\n/**\n * Get the 'data-vimeo'-prefixed attributes from an element as an object.\n *\n * @param {HTMLElement} element The element.\n * @param {Object} [defaults={}] The default values to use.\n * @return {Object<string, string>}\n */\n\nfunction getOEmbedParameters(element) {\n  var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return oEmbedParameters.reduce(function (params, param) {\n    var value = element.getAttribute(\"data-vimeo-\".concat(param));\n\n    if (value || value === '') {\n      params[param] = value === '' ? 1 : value;\n    }\n\n    return params;\n  }, defaults);\n}\n/**\n * Create an embed from oEmbed data inside an element.\n *\n * @param {object} data The oEmbed data.\n * @param {HTMLElement} element The element to put the iframe in.\n * @return {HTMLIFrameElement} The iframe embed.\n */\n\nfunction createEmbed(_ref, element) {\n  var html = _ref.html;\n\n  if (!element) {\n    throw new TypeError('An element must be provided');\n  }\n\n  if (element.getAttribute('data-vimeo-initialized') !== null) {\n    return element.querySelector('iframe');\n  }\n\n  var div = document.createElement('div');\n  div.innerHTML = html;\n  element.appendChild(div.firstChild);\n  element.setAttribute('data-vimeo-initialized', 'true');\n  return element.querySelector('iframe');\n}\n/**\n * Make an oEmbed call for the specified URL.\n *\n * @param {string} videoUrl The vimeo.com url for the video.\n * @param {Object} [params] Parameters to pass to oEmbed.\n * @param {HTMLElement} element The element.\n * @return {Promise}\n */\n\nfunction getOEmbedData(videoUrl) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var element = arguments.length > 2 ? arguments[2] : undefined;\n  return new Promise(function (resolve, reject) {\n    if (!isVimeoUrl(videoUrl)) {\n      throw new TypeError(\"\\u201C\".concat(videoUrl, \"\\u201D is not a vimeo.com url.\"));\n    }\n\n    var url = \"https://vimeo.com/api/oembed.json?url=\".concat(encodeURIComponent(videoUrl));\n\n    for (var param in params) {\n      if (params.hasOwnProperty(param)) {\n        url += \"&\".concat(param, \"=\").concat(encodeURIComponent(params[param]));\n      }\n    }\n\n    var xhr = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();\n    xhr.open('GET', url, true);\n\n    xhr.onload = function () {\n      if (xhr.status === 404) {\n        reject(new Error(\"\\u201C\".concat(videoUrl, \"\\u201D was not found.\")));\n        return;\n      }\n\n      if (xhr.status === 403) {\n        reject(new Error(\"\\u201C\".concat(videoUrl, \"\\u201D is not embeddable.\")));\n        return;\n      }\n\n      try {\n        var json = JSON.parse(xhr.responseText); // Check api response for 403 on oembed\n\n        if (json.domain_status_code === 403) {\n          // We still want to create the embed to give users visual feedback\n          createEmbed(json, element);\n          reject(new Error(\"\\u201C\".concat(videoUrl, \"\\u201D is not embeddable.\")));\n          return;\n        }\n\n        resolve(json);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    xhr.onerror = function () {\n      var status = xhr.status ? \" (\".concat(xhr.status, \")\") : '';\n      reject(new Error(\"There was an error fetching the embed code from Vimeo\".concat(status, \".\")));\n    };\n\n    xhr.send();\n  });\n}\n/**\n * Initialize all embeds within a specific element\n *\n * @param {HTMLElement} [parent=document] The parent element.\n * @return {void}\n */\n\nfunction initializeEmbeds() {\n  var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n  var elements = [].slice.call(parent.querySelectorAll('[data-vimeo-id], [data-vimeo-url]'));\n\n  var handleError = function handleError(error) {\n    if ('console' in window && console.error) {\n      console.error(\"There was an error creating an embed: \".concat(error));\n    }\n  };\n\n  elements.forEach(function (element) {\n    try {\n      // Skip any that have data-vimeo-defer\n      if (element.getAttribute('data-vimeo-defer') !== null) {\n        return;\n      }\n\n      var params = getOEmbedParameters(element);\n      var url = getVimeoUrl(params);\n      getOEmbedData(url, params, element).then(function (data) {\n        return createEmbed(data, element);\n      }).catch(handleError);\n    } catch (error) {\n      handleError(error);\n    }\n  });\n}\n/**\n * Resize embeds when messaged by the player.\n *\n * @param {HTMLElement} [parent=document] The parent element.\n * @return {void}\n */\n\nfunction resizeEmbeds() {\n  var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n\n  // Prevent execution if users include the player.js script multiple times.\n  if (window.VimeoPlayerResizeEmbeds_) {\n    return;\n  }\n\n  window.VimeoPlayerResizeEmbeds_ = true;\n\n  var onMessage = function onMessage(event) {\n    if (!isVimeoUrl(event.origin)) {\n      return;\n    } // 'spacechange' is fired only on embeds with cards\n\n\n    if (!event.data || event.data.event !== 'spacechange') {\n      return;\n    }\n\n    var iframes = parent.querySelectorAll('iframe');\n\n    for (var i = 0; i < iframes.length; i++) {\n      if (iframes[i].contentWindow !== event.source) {\n        continue;\n      } // Change padding-bottom of the enclosing div to accommodate\n      // card carousel without distorting aspect ratio\n\n\n      var space = iframes[i].parentElement;\n      space.style.paddingBottom = \"\".concat(event.data.data[0].bottom, \"px\");\n      break;\n    }\n  };\n\n  window.addEventListener('message', onMessage);\n}\n/**\n * Add chapters to existing metadata for Google SEO\n *\n * @param {HTMLElement} [parent=document] The parent element.\n * @return {void}\n */\n\nfunction initAppendVideoMetadata() {\n  var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n\n  //  Prevent execution if users include the player.js script multiple times.\n  if (window.VimeoSeoMetadataAppended) {\n    return;\n  }\n\n  window.VimeoSeoMetadataAppended = true;\n\n  var onMessage = function onMessage(event) {\n    if (!isVimeoUrl(event.origin)) {\n      return;\n    }\n\n    var data = parseMessageData(event.data);\n\n    if (!data || data.event !== 'ready') {\n      return;\n    }\n\n    var iframes = parent.querySelectorAll('iframe');\n\n    for (var i = 0; i < iframes.length; i++) {\n      var iframe = iframes[i]; // Initiate appendVideoMetadata if iframe is a Vimeo embed\n\n      var isValidMessageSource = iframe.contentWindow === event.source;\n\n      if (isVimeoEmbed(iframe.src) && isValidMessageSource) {\n        var player = new Player(iframe);\n        player.callMethod('appendVideoMetadata', window.location.href);\n      }\n    }\n  };\n\n  window.addEventListener('message', onMessage);\n}\n\n/* MIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nTerms */\nfunction initializeScreenfull() {\n  var fn = function () {\n    var val;\n    var fnMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'], // New WebKit\n    ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'], // Old WebKit\n    ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];\n    var i = 0;\n    var l = fnMap.length;\n    var ret = {};\n\n    for (; i < l; i++) {\n      val = fnMap[i];\n\n      if (val && val[1] in document) {\n        for (i = 0; i < val.length; i++) {\n          ret[fnMap[0][i]] = val[i];\n        }\n\n        return ret;\n      }\n    }\n\n    return false;\n  }();\n\n  var eventNameMap = {\n    fullscreenchange: fn.fullscreenchange,\n    fullscreenerror: fn.fullscreenerror\n  };\n  var screenfull = {\n    request: function request(element) {\n      return new Promise(function (resolve, reject) {\n        var onFullScreenEntered = function onFullScreenEntered() {\n          screenfull.off('fullscreenchange', onFullScreenEntered);\n          resolve();\n        };\n\n        screenfull.on('fullscreenchange', onFullScreenEntered);\n        element = element || document.documentElement;\n        var returnPromise = element[fn.requestFullscreen]();\n\n        if (returnPromise instanceof Promise) {\n          returnPromise.then(onFullScreenEntered).catch(reject);\n        }\n      });\n    },\n    exit: function exit() {\n      return new Promise(function (resolve, reject) {\n        if (!screenfull.isFullscreen) {\n          resolve();\n          return;\n        }\n\n        var onFullScreenExit = function onFullScreenExit() {\n          screenfull.off('fullscreenchange', onFullScreenExit);\n          resolve();\n        };\n\n        screenfull.on('fullscreenchange', onFullScreenExit);\n        var returnPromise = document[fn.exitFullscreen]();\n\n        if (returnPromise instanceof Promise) {\n          returnPromise.then(onFullScreenExit).catch(reject);\n        }\n      });\n    },\n    on: function on(event, callback) {\n      var eventName = eventNameMap[event];\n\n      if (eventName) {\n        document.addEventListener(eventName, callback);\n      }\n    },\n    off: function off(event, callback) {\n      var eventName = eventNameMap[event];\n\n      if (eventName) {\n        document.removeEventListener(eventName, callback);\n      }\n    }\n  };\n  Object.defineProperties(screenfull, {\n    isFullscreen: {\n      get: function get() {\n        return Boolean(document[fn.fullscreenElement]);\n      }\n    },\n    element: {\n      enumerable: true,\n      get: function get() {\n        return document[fn.fullscreenElement];\n      }\n    },\n    isEnabled: {\n      enumerable: true,\n      get: function get() {\n        // Coerce to boolean in case of old WebKit\n        return Boolean(document[fn.fullscreenEnabled]);\n      }\n    }\n  });\n  return screenfull;\n}\n\nvar playerMap = new WeakMap();\nvar readyMap = new WeakMap();\nvar screenfull = {};\n\nvar Player = /*#__PURE__*/function () {\n  /**\n   * Create a Player.\n   *\n   * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to the Vimeo\n   *        player iframe, and id, or a jQuery object.\n   * @param {object} [options] oEmbed parameters to use when creating an embed in the element.\n   * @return {Player}\n   */\n  function Player(element) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Player);\n\n    /* global jQuery */\n    if (window.jQuery && element instanceof jQuery) {\n      if (element.length > 1 && window.console && console.warn) {\n        console.warn('A jQuery object with multiple elements was passed, using the first element.');\n      }\n\n      element = element[0];\n    } // Find an element by ID\n\n\n    if (typeof document !== 'undefined' && typeof element === 'string') {\n      element = document.getElementById(element);\n    } // Not an element!\n\n\n    if (!isDomElement(element)) {\n      throw new TypeError('You must pass either a valid element or a valid id.');\n    } // Already initialized an embed in this div, so grab the iframe\n\n\n    if (element.nodeName !== 'IFRAME') {\n      var iframe = element.querySelector('iframe');\n\n      if (iframe) {\n        element = iframe;\n      }\n    } // iframe url is not a Vimeo url\n\n\n    if (element.nodeName === 'IFRAME' && !isVimeoUrl(element.getAttribute('src') || '')) {\n      throw new Error('The player element passed isnt a Vimeo embed.');\n    } // If there is already a player object in the map, return that\n\n\n    if (playerMap.has(element)) {\n      return playerMap.get(element);\n    }\n\n    this._window = element.ownerDocument.defaultView;\n    this.element = element;\n    this.origin = '*';\n    var readyPromise = new npo_src(function (resolve, reject) {\n      _this._onMessage = function (event) {\n        if (!isVimeoUrl(event.origin) || _this.element.contentWindow !== event.source) {\n          return;\n        }\n\n        if (_this.origin === '*') {\n          _this.origin = event.origin;\n        }\n\n        var data = parseMessageData(event.data);\n        var isError = data && data.event === 'error';\n        var isReadyError = isError && data.data && data.data.method === 'ready';\n\n        if (isReadyError) {\n          var error = new Error(data.data.message);\n          error.name = data.data.name;\n          reject(error);\n          return;\n        }\n\n        var isReadyEvent = data && data.event === 'ready';\n        var isPingResponse = data && data.method === 'ping';\n\n        if (isReadyEvent || isPingResponse) {\n          _this.element.setAttribute('data-ready', 'true');\n\n          resolve();\n          return;\n        }\n\n        processData(_this, data);\n      };\n\n      _this._window.addEventListener('message', _this._onMessage);\n\n      if (_this.element.nodeName !== 'IFRAME') {\n        var params = getOEmbedParameters(element, options);\n        var url = getVimeoUrl(params);\n        getOEmbedData(url, params, element).then(function (data) {\n          var iframe = createEmbed(data, element); // Overwrite element with the new iframe,\n          // but store reference to the original element\n\n          _this.element = iframe;\n          _this._originalElement = element;\n          swapCallbacks(element, iframe);\n          playerMap.set(_this.element, _this);\n          return data;\n        }).catch(reject);\n      }\n    }); // Store a copy of this Player in the map\n\n    readyMap.set(this, readyPromise);\n    playerMap.set(this.element, this); // Send a ping to the iframe so the ready promise will be resolved if\n    // the player is already ready.\n\n    if (this.element.nodeName === 'IFRAME') {\n      postMessage(this, 'ping');\n    }\n\n    if (screenfull.isEnabled) {\n      var exitFullscreen = function exitFullscreen() {\n        return screenfull.exit();\n      };\n\n      this.fullscreenchangeHandler = function () {\n        if (screenfull.isFullscreen) {\n          storeCallback(_this, 'event:exitFullscreen', exitFullscreen);\n        } else {\n          removeCallback(_this, 'event:exitFullscreen', exitFullscreen);\n        } // eslint-disable-next-line\n\n\n        _this.ready().then(function () {\n          postMessage(_this, 'fullscreenchange', screenfull.isFullscreen);\n        });\n      };\n\n      screenfull.on('fullscreenchange', this.fullscreenchangeHandler);\n    }\n\n    return this;\n  }\n  /**\n   * Get a promise for a method.\n   *\n   * @param {string} name The API method to call.\n   * @param {Object} [args={}] Arguments to send via postMessage.\n   * @return {Promise}\n   */\n\n\n  _createClass(Player, [{\n    key: \"callMethod\",\n    value: function callMethod(name) {\n      var _this2 = this;\n\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new npo_src(function (resolve, reject) {\n        // We are storing the resolve/reject handlers to call later, so we\n        // cant return here.\n        // eslint-disable-next-line promise/always-return\n        return _this2.ready().then(function () {\n          storeCallback(_this2, name, {\n            resolve: resolve,\n            reject: reject\n          });\n          postMessage(_this2, name, args);\n        }).catch(reject);\n      });\n    }\n    /**\n     * Get a promise for the value of a player property.\n     *\n     * @param {string} name The property name\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      var _this3 = this;\n\n      return new npo_src(function (resolve, reject) {\n        name = getMethodName(name, 'get'); // We are storing the resolve/reject handlers to call later, so we\n        // cant return here.\n        // eslint-disable-next-line promise/always-return\n\n        return _this3.ready().then(function () {\n          storeCallback(_this3, name, {\n            resolve: resolve,\n            reject: reject\n          });\n          postMessage(_this3, name);\n        }).catch(reject);\n      });\n    }\n    /**\n     * Get a promise for setting the value of a player property.\n     *\n     * @param {string} name The API method to call.\n     * @param {mixed} value The value to set.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(name, value) {\n      var _this4 = this;\n\n      return new npo_src(function (resolve, reject) {\n        name = getMethodName(name, 'set');\n\n        if (value === undefined || value === null) {\n          throw new TypeError('There must be a value to set.');\n        } // We are storing the resolve/reject handlers to call later, so we\n        // cant return here.\n        // eslint-disable-next-line promise/always-return\n\n\n        return _this4.ready().then(function () {\n          storeCallback(_this4, name, {\n            resolve: resolve,\n            reject: reject\n          });\n          postMessage(_this4, name, value);\n        }).catch(reject);\n      });\n    }\n    /**\n     * Add an event listener for the specified event. Will call the\n     * callback with a single parameter, `data`, that contains the data for\n     * that event.\n     *\n     * @param {string} eventName The name of the event.\n     * @param {function(*)} callback The function to call when the event fires.\n     * @return {void}\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      if (!eventName) {\n        throw new TypeError('You must pass an event name.');\n      }\n\n      if (!callback) {\n        throw new TypeError('You must pass a callback function.');\n      }\n\n      if (typeof callback !== 'function') {\n        throw new TypeError('The callback must be a function.');\n      }\n\n      var callbacks = getCallbacks(this, \"event:\".concat(eventName));\n\n      if (callbacks.length === 0) {\n        this.callMethod('addEventListener', eventName).catch(function () {// Ignore the error. There will be an error event fired that\n          // will trigger the error callback if they are listening.\n        });\n      }\n\n      storeCallback(this, \"event:\".concat(eventName), callback);\n    }\n    /**\n     * Remove an event listener for the specified event. Will remove all\n     * listeners for that event if a `callback` isnt passed, or only that\n     * specific callback if it is passed.\n     *\n     * @param {string} eventName The name of the event.\n     * @param {function} [callback] The specific callback to remove.\n     * @return {void}\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, callback) {\n      if (!eventName) {\n        throw new TypeError('You must pass an event name.');\n      }\n\n      if (callback && typeof callback !== 'function') {\n        throw new TypeError('The callback must be a function.');\n      }\n\n      var lastCallback = removeCallback(this, \"event:\".concat(eventName), callback); // If there are no callbacks left, remove the listener\n\n      if (lastCallback) {\n        this.callMethod('removeEventListener', eventName).catch(function (e) {// Ignore the error. There will be an error event fired that\n          // will trigger the error callback if they are listening.\n        });\n      }\n    }\n    /**\n     * A promise to load a new video.\n     *\n     * @promise LoadVideoPromise\n     * @fulfill {number} The video with this id or url successfully loaded.\n     * @reject {TypeError} The id was not a number.\n     */\n\n    /**\n     * Load a new video into this embed. The promise will be resolved if\n     * the video is successfully loaded, or it will be rejected if it could\n     * not be loaded.\n     *\n     * @param {number|string|object} options The id of the video, the url of the video, or an object with embed options.\n     * @return {LoadVideoPromise}\n     */\n\n  }, {\n    key: \"loadVideo\",\n    value: function loadVideo(options) {\n      return this.callMethod('loadVideo', options);\n    }\n    /**\n     * A promise to perform an action when the Player is ready.\n     *\n     * @todo document errors\n     * @promise LoadVideoPromise\n     * @fulfill {void}\n     */\n\n    /**\n     * Trigger a function when the player iframe has initialized. You do not\n     * need to wait for `ready` to trigger to begin adding event listeners\n     * or calling other methods.\n     *\n     * @return {ReadyPromise}\n     */\n\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      var readyPromise = readyMap.get(this) || new npo_src(function (resolve, reject) {\n        reject(new Error('Unknown player. Probably unloaded.'));\n      });\n      return npo_src.resolve(readyPromise);\n    }\n    /**\n     * A promise to add a cue point to the player.\n     *\n     * @promise AddCuePointPromise\n     * @fulfill {string} The id of the cue point to use for removeCuePoint.\n     * @reject {RangeError} the time was less than 0 or greater than the\n     *         videos duration.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n\n    /**\n     * Add a cue point to the player.\n     *\n     * @param {number} time The time for the cue point.\n     * @param {object} [data] Arbitrary data to be returned with the cue point.\n     * @return {AddCuePointPromise}\n     */\n\n  }, {\n    key: \"addCuePoint\",\n    value: function addCuePoint(time) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.callMethod('addCuePoint', {\n        time: time,\n        data: data\n      });\n    }\n    /**\n     * A promise to remove a cue point from the player.\n     *\n     * @promise AddCuePointPromise\n     * @fulfill {string} The id of the cue point that was removed.\n     * @reject {InvalidCuePoint} The cue point with the specified id was not\n     *         found.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n\n    /**\n     * Remove a cue point from the video.\n     *\n     * @param {string} id The id of the cue point to remove.\n     * @return {RemoveCuePointPromise}\n     */\n\n  }, {\n    key: \"removeCuePoint\",\n    value: function removeCuePoint(id) {\n      return this.callMethod('removeCuePoint', id);\n    }\n    /**\n     * A representation of a text track on a video.\n     *\n     * @typedef {Object} VimeoTextTrack\n     * @property {string} language The ISO language code.\n     * @property {string} kind The kind of track it is (captions or subtitles).\n     * @property {string} label The humanreadable label for the track.\n     */\n\n    /**\n     * A promise to enable a text track.\n     *\n     * @promise EnableTextTrackPromise\n     * @fulfill {VimeoTextTrack} The text track that was enabled.\n     * @reject {InvalidTrackLanguageError} No track was available with the\n     *         specified language.\n     * @reject {InvalidTrackError} No track was available with the specified\n     *         language and kind.\n     */\n\n    /**\n     * Enable the text track with the specified language, and optionally the\n     * specified kind (captions or subtitles).\n     *\n     * When set via the API, the track language will not change the viewers\n     * stored preference.\n     *\n     * @param {string} language The twoletter language code.\n     * @param {string} [kind] The kind of track to enable (captions or subtitles).\n     * @return {EnableTextTrackPromise}\n     */\n\n  }, {\n    key: \"enableTextTrack\",\n    value: function enableTextTrack(language, kind) {\n      if (!language) {\n        throw new TypeError('You must pass a language.');\n      }\n\n      return this.callMethod('enableTextTrack', {\n        language: language,\n        kind: kind\n      });\n    }\n    /**\n     * A promise to disable the active text track.\n     *\n     * @promise DisableTextTrackPromise\n     * @fulfill {void} The track was disabled.\n     */\n\n    /**\n     * Disable the currently-active text track.\n     *\n     * @return {DisableTextTrackPromise}\n     */\n\n  }, {\n    key: \"disableTextTrack\",\n    value: function disableTextTrack() {\n      return this.callMethod('disableTextTrack');\n    }\n    /**\n     * A promise to pause the video.\n     *\n     * @promise PausePromise\n     * @fulfill {void} The video was paused.\n     */\n\n    /**\n     * Pause the video if its playing.\n     *\n     * @return {PausePromise}\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      return this.callMethod('pause');\n    }\n    /**\n     * A promise to play the video.\n     *\n     * @promise PlayPromise\n     * @fulfill {void} The video was played.\n     */\n\n    /**\n     * Play the video if its paused. **Note:** on iOS and some other\n     * mobile devices, you cannot programmatically trigger play. Once the\n     * viewer has tapped on the play button in the player, however, you\n     * will be able to use this function.\n     *\n     * @return {PlayPromise}\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      return this.callMethod('play');\n    }\n    /**\n     * Request that the player enters fullscreen.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"requestFullscreen\",\n    value: function requestFullscreen() {\n      if (screenfull.isEnabled) {\n        return screenfull.request(this.element);\n      }\n\n      return this.callMethod('requestFullscreen');\n    }\n    /**\n     * Request that the player exits fullscreen.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"exitFullscreen\",\n    value: function exitFullscreen() {\n      if (screenfull.isEnabled) {\n        return screenfull.exit();\n      }\n\n      return this.callMethod('exitFullscreen');\n    }\n    /**\n     * Returns true if the player is currently fullscreen.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"getFullscreen\",\n    value: function getFullscreen() {\n      if (screenfull.isEnabled) {\n        return npo_src.resolve(screenfull.isFullscreen);\n      }\n\n      return this.get('fullscreen');\n    }\n    /**\n     * Request that the player enters picture-in-picture.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"requestPictureInPicture\",\n    value: function requestPictureInPicture() {\n      return this.callMethod('requestPictureInPicture');\n    }\n    /**\n     * Request that the player exits picture-in-picture.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"exitPictureInPicture\",\n    value: function exitPictureInPicture() {\n      return this.callMethod('exitPictureInPicture');\n    }\n    /**\n     * Returns true if the player is currently picture-in-picture.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"getPictureInPicture\",\n    value: function getPictureInPicture() {\n      return this.get('pictureInPicture');\n    }\n    /**\n     * A promise to unload the video.\n     *\n     * @promise UnloadPromise\n     * @fulfill {void} The video was unloaded.\n     */\n\n    /**\n     * Return the player to its initial state.\n     *\n     * @return {UnloadPromise}\n     */\n\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      return this.callMethod('unload');\n    }\n    /**\n     * Cleanup the player and remove it from the DOM\n     *\n     * It won't be usable and a new one should be constructed\n     *  in order to do any operations.\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this5 = this;\n\n      return new npo_src(function (resolve) {\n        readyMap.delete(_this5);\n        playerMap.delete(_this5.element);\n\n        if (_this5._originalElement) {\n          playerMap.delete(_this5._originalElement);\n\n          _this5._originalElement.removeAttribute('data-vimeo-initialized');\n        }\n\n        if (_this5.element && _this5.element.nodeName === 'IFRAME' && _this5.element.parentNode) {\n          // If we've added an additional wrapper div, remove that from the DOM.\n          // If not, just remove the iframe element.\n          if (_this5.element.parentNode.parentNode && _this5._originalElement && _this5._originalElement !== _this5.element.parentNode) {\n            _this5.element.parentNode.parentNode.removeChild(_this5.element.parentNode);\n          } else {\n            _this5.element.parentNode.removeChild(_this5.element);\n          }\n        } // If the clip is private there is a case where the element stays the\n        // div element. Destroy should reset the div and remove the iframe child.\n\n\n        if (_this5.element && _this5.element.nodeName === 'DIV' && _this5.element.parentNode) {\n          _this5.element.removeAttribute('data-vimeo-initialized');\n\n          var iframe = _this5.element.querySelector('iframe');\n\n          if (iframe && iframe.parentNode) {\n            // If we've added an additional wrapper div, remove that from the DOM.\n            // If not, just remove the iframe element.\n            if (iframe.parentNode.parentNode && _this5._originalElement && _this5._originalElement !== iframe.parentNode) {\n              iframe.parentNode.parentNode.removeChild(iframe.parentNode);\n            } else {\n              iframe.parentNode.removeChild(iframe);\n            }\n          }\n        }\n\n        _this5._window.removeEventListener('message', _this5._onMessage);\n\n        if (screenfull.isEnabled) {\n          screenfull.off('fullscreenchange', _this5.fullscreenchangeHandler);\n        }\n\n        resolve();\n      });\n    }\n    /**\n     * A promise to get the autopause behavior of the video.\n     *\n     * @promise GetAutopausePromise\n     * @fulfill {boolean} Whether autopause is turned on or off.\n     * @reject {UnsupportedError} Autopause is not supported with the current\n     *         player or browser.\n     */\n\n    /**\n     * Get the autopause behavior for this player.\n     *\n     * @return {GetAutopausePromise}\n     */\n\n  }, {\n    key: \"getAutopause\",\n    value: function getAutopause() {\n      return this.get('autopause');\n    }\n    /**\n     * A promise to set the autopause behavior of the video.\n     *\n     * @promise SetAutopausePromise\n     * @fulfill {boolean} Whether autopause is turned on or off.\n     * @reject {UnsupportedError} Autopause is not supported with the current\n     *         player or browser.\n     */\n\n    /**\n     * Enable or disable the autopause behavior of this player.\n     *\n     * By default, when another video is played in the same browser, this\n     * player will automatically pause. Unless you have a specific reason\n     * for doing so, we recommend that you leave autopause set to the\n     * default (`true`).\n     *\n     * @param {boolean} autopause\n     * @return {SetAutopausePromise}\n     */\n\n  }, {\n    key: \"setAutopause\",\n    value: function setAutopause(autopause) {\n      return this.set('autopause', autopause);\n    }\n    /**\n     * A promise to get the buffered property of the video.\n     *\n     * @promise GetBufferedPromise\n     * @fulfill {Array} Buffered Timeranges converted to an Array.\n     */\n\n    /**\n     * Get the buffered property of the video.\n     *\n     * @return {GetBufferedPromise}\n     */\n\n  }, {\n    key: \"getBuffered\",\n    value: function getBuffered() {\n      return this.get('buffered');\n    }\n    /**\n     * @typedef {Object} CameraProperties\n     * @prop {number} props.yaw - Number between 0 and 360.\n     * @prop {number} props.pitch - Number between -90 and 90.\n     * @prop {number} props.roll - Number between -180 and 180.\n     * @prop {number} props.fov - The field of view in degrees.\n     */\n\n    /**\n     * A promise to get the camera properties of the player.\n     *\n     * @promise GetCameraPromise\n     * @fulfill {CameraProperties} The camera properties.\n     */\n\n    /**\n     * For 360 videos get the camera properties for this player.\n     *\n     * @return {GetCameraPromise}\n     */\n\n  }, {\n    key: \"getCameraProps\",\n    value: function getCameraProps() {\n      return this.get('cameraProps');\n    }\n    /**\n     * A promise to set the camera properties of the player.\n     *\n     * @promise SetCameraPromise\n     * @fulfill {Object} The camera was successfully set.\n     * @reject {RangeError} The range was out of bounds.\n     */\n\n    /**\n     * For 360 videos set the camera properties for this player.\n     *\n     * @param {CameraProperties} camera The camera properties\n     * @return {SetCameraPromise}\n     */\n\n  }, {\n    key: \"setCameraProps\",\n    value: function setCameraProps(camera) {\n      return this.set('cameraProps', camera);\n    }\n    /**\n     * A representation of a chapter.\n     *\n     * @typedef {Object} VimeoChapter\n     * @property {number} startTime The start time of the chapter.\n     * @property {object} title The title of the chapter.\n     * @property {number} index The place in the order of Chapters. Starts at 1.\n     */\n\n    /**\n     * A promise to get chapters for the video.\n     *\n     * @promise GetChaptersPromise\n     * @fulfill {VimeoChapter[]} The chapters for the video.\n     */\n\n    /**\n     * Get an array of all the chapters for the video.\n     *\n     * @return {GetChaptersPromise}\n     */\n\n  }, {\n    key: \"getChapters\",\n    value: function getChapters() {\n      return this.get('chapters');\n    }\n    /**\n     * A promise to get the currently active chapter.\n     *\n     * @promise GetCurrentChaptersPromise\n     * @fulfill {VimeoChapter|undefined} The current chapter for the video.\n     */\n\n    /**\n     * Get the currently active chapter for the video.\n     *\n     * @return {GetCurrentChaptersPromise}\n     */\n\n  }, {\n    key: \"getCurrentChapter\",\n    value: function getCurrentChapter() {\n      return this.get('currentChapter');\n    }\n    /**\n     * A promise to get the color of the player.\n     *\n     * @promise GetColorPromise\n     * @fulfill {string} The hex color of the player.\n     */\n\n    /**\n     * Get the color for this player.\n     *\n     * @return {GetColorPromise}\n     */\n\n  }, {\n    key: \"getColor\",\n    value: function getColor() {\n      return this.get('color');\n    }\n    /**\n     * A promise to set the color of the player.\n     *\n     * @promise SetColorPromise\n     * @fulfill {string} The color was successfully set.\n     * @reject {TypeError} The string was not a valid hex or rgb color.\n     * @reject {ContrastError} The color was set, but the contrast is\n     *         outside of the acceptable range.\n     * @reject {EmbedSettingsError} The owner of the player has chosen to\n     *         use a specific color.\n     */\n\n    /**\n     * Set the color of this player to a hex or rgb string. Setting the\n     * color may fail if the owner of the video has set their embed\n     * preferences to force a specific color.\n     *\n     * @param {string} color The hex or rgb color string to set.\n     * @return {SetColorPromise}\n     */\n\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      return this.set('color', color);\n    }\n    /**\n     * A representation of a cue point.\n     *\n     * @typedef {Object} VimeoCuePoint\n     * @property {number} time The time of the cue point.\n     * @property {object} data The data passed when adding the cue point.\n     * @property {string} id The unique id for use with removeCuePoint.\n     */\n\n    /**\n     * A promise to get the cue points of a video.\n     *\n     * @promise GetCuePointsPromise\n     * @fulfill {VimeoCuePoint[]} The cue points added to the video.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n\n    /**\n     * Get an array of the cue points added to the video.\n     *\n     * @return {GetCuePointsPromise}\n     */\n\n  }, {\n    key: \"getCuePoints\",\n    value: function getCuePoints() {\n      return this.get('cuePoints');\n    }\n    /**\n     * A promise to get the current time of the video.\n     *\n     * @promise GetCurrentTimePromise\n     * @fulfill {number} The current time in seconds.\n     */\n\n    /**\n     * Get the current playback position in seconds.\n     *\n     * @return {GetCurrentTimePromise}\n     */\n\n  }, {\n    key: \"getCurrentTime\",\n    value: function getCurrentTime() {\n      return this.get('currentTime');\n    }\n    /**\n     * A promise to set the current time of the video.\n     *\n     * @promise SetCurrentTimePromise\n     * @fulfill {number} The actual current time that was set.\n     * @reject {RangeError} the time was less than 0 or greater than the\n     *         videos duration.\n     */\n\n    /**\n     * Set the current playback position in seconds. If the player was\n     * paused, it will remain paused. Likewise, if the player was playing,\n     * it will resume playing once the video has buffered.\n     *\n     * You can provide an accurate time and the player will attempt to seek\n     * to as close to that time as possible. The exact time will be the\n     * fulfilled value of the promise.\n     *\n     * @param {number} currentTime\n     * @return {SetCurrentTimePromise}\n     */\n\n  }, {\n    key: \"setCurrentTime\",\n    value: function setCurrentTime(currentTime) {\n      return this.set('currentTime', currentTime);\n    }\n    /**\n     * A promise to get the duration of the video.\n     *\n     * @promise GetDurationPromise\n     * @fulfill {number} The duration in seconds.\n     */\n\n    /**\n     * Get the duration of the video in seconds. It will be rounded to the\n     * nearest second before playback begins, and to the nearest thousandth\n     * of a second after playback begins.\n     *\n     * @return {GetDurationPromise}\n     */\n\n  }, {\n    key: \"getDuration\",\n    value: function getDuration() {\n      return this.get('duration');\n    }\n    /**\n     * A promise to get the ended state of the video.\n     *\n     * @promise GetEndedPromise\n     * @fulfill {boolean} Whether or not the video has ended.\n     */\n\n    /**\n     * Get the ended state of the video. The video has ended if\n     * `currentTime === duration`.\n     *\n     * @return {GetEndedPromise}\n     */\n\n  }, {\n    key: \"getEnded\",\n    value: function getEnded() {\n      return this.get('ended');\n    }\n    /**\n     * A promise to get the loop state of the player.\n     *\n     * @promise GetLoopPromise\n     * @fulfill {boolean} Whether or not the player is set to loop.\n     */\n\n    /**\n     * Get the loop state of the player.\n     *\n     * @return {GetLoopPromise}\n     */\n\n  }, {\n    key: \"getLoop\",\n    value: function getLoop() {\n      return this.get('loop');\n    }\n    /**\n     * A promise to set the loop state of the player.\n     *\n     * @promise SetLoopPromise\n     * @fulfill {boolean} The loop state that was set.\n     */\n\n    /**\n     * Set the loop state of the player. When set to `true`, the player\n     * will start over immediately once playback ends.\n     *\n     * @param {boolean} loop\n     * @return {SetLoopPromise}\n     */\n\n  }, {\n    key: \"setLoop\",\n    value: function setLoop(loop) {\n      return this.set('loop', loop);\n    }\n    /**\n     * A promise to set the muted state of the player.\n     *\n     * @promise SetMutedPromise\n     * @fulfill {boolean} The muted state that was set.\n     */\n\n    /**\n     * Set the muted state of the player. When set to `true`, the player\n     * volume will be muted.\n     *\n     * @param {boolean} muted\n     * @return {SetMutedPromise}\n     */\n\n  }, {\n    key: \"setMuted\",\n    value: function setMuted(muted) {\n      return this.set('muted', muted);\n    }\n    /**\n     * A promise to get the muted state of the player.\n     *\n     * @promise GetMutedPromise\n     * @fulfill {boolean} Whether or not the player is muted.\n     */\n\n    /**\n     * Get the muted state of the player.\n     *\n     * @return {GetMutedPromise}\n     */\n\n  }, {\n    key: \"getMuted\",\n    value: function getMuted() {\n      return this.get('muted');\n    }\n    /**\n     * A promise to get the paused state of the player.\n     *\n     * @promise GetLoopPromise\n     * @fulfill {boolean} Whether or not the video is paused.\n     */\n\n    /**\n     * Get the paused state of the player.\n     *\n     * @return {GetLoopPromise}\n     */\n\n  }, {\n    key: \"getPaused\",\n    value: function getPaused() {\n      return this.get('paused');\n    }\n    /**\n     * A promise to get the playback rate of the player.\n     *\n     * @promise GetPlaybackRatePromise\n     * @fulfill {number} The playback rate of the player on a scale from 0.5 to 2.\n     */\n\n    /**\n     * Get the playback rate of the player on a scale from `0.5` to `2`.\n     *\n     * @return {GetPlaybackRatePromise}\n     */\n\n  }, {\n    key: \"getPlaybackRate\",\n    value: function getPlaybackRate() {\n      return this.get('playbackRate');\n    }\n    /**\n     * A promise to set the playbackrate of the player.\n     *\n     * @promise SetPlaybackRatePromise\n     * @fulfill {number} The playback rate was set.\n     * @reject {RangeError} The playback rate was less than 0.5 or greater than 2.\n     */\n\n    /**\n     * Set the playback rate of the player on a scale from `0.5` to `2`. When set\n     * via the API, the playback rate will not be synchronized to other\n     * players or stored as the viewer's preference.\n     *\n     * @param {number} playbackRate\n     * @return {SetPlaybackRatePromise}\n     */\n\n  }, {\n    key: \"setPlaybackRate\",\n    value: function setPlaybackRate(playbackRate) {\n      return this.set('playbackRate', playbackRate);\n    }\n    /**\n     * A promise to get the played property of the video.\n     *\n     * @promise GetPlayedPromise\n     * @fulfill {Array} Played Timeranges converted to an Array.\n     */\n\n    /**\n     * Get the played property of the video.\n     *\n     * @return {GetPlayedPromise}\n     */\n\n  }, {\n    key: \"getPlayed\",\n    value: function getPlayed() {\n      return this.get('played');\n    }\n    /**\n     * A promise to get the qualities available of the current video.\n     *\n     * @promise GetQualitiesPromise\n     * @fulfill {Array} The qualities of the video.\n     */\n\n    /**\n     * Get the qualities of the current video.\n     *\n     * @return {GetQualitiesPromise}\n     */\n\n  }, {\n    key: \"getQualities\",\n    value: function getQualities() {\n      return this.get('qualities');\n    }\n    /**\n     * A promise to get the current set quality of the video.\n     *\n     * @promise GetQualityPromise\n     * @fulfill {string} The current set quality.\n     */\n\n    /**\n     * Get the current set quality of the video.\n     *\n     * @return {GetQualityPromise}\n     */\n\n  }, {\n    key: \"getQuality\",\n    value: function getQuality() {\n      return this.get('quality');\n    }\n    /**\n     * A promise to set the video quality.\n     *\n     * @promise SetQualityPromise\n     * @fulfill {number} The quality was set.\n     * @reject {RangeError} The quality is not available.\n     */\n\n    /**\n     * Set a video quality.\n     *\n     * @param {string} quality\n     * @return {SetQualityPromise}\n     */\n\n  }, {\n    key: \"setQuality\",\n    value: function setQuality(quality) {\n      return this.set('quality', quality);\n    }\n    /**\n     * A promise to get the seekable property of the video.\n     *\n     * @promise GetSeekablePromise\n     * @fulfill {Array} Seekable Timeranges converted to an Array.\n     */\n\n    /**\n     * Get the seekable property of the video.\n     *\n     * @return {GetSeekablePromise}\n     */\n\n  }, {\n    key: \"getSeekable\",\n    value: function getSeekable() {\n      return this.get('seekable');\n    }\n    /**\n     * A promise to get the seeking property of the player.\n     *\n     * @promise GetSeekingPromise\n     * @fulfill {boolean} Whether or not the player is currently seeking.\n     */\n\n    /**\n     * Get if the player is currently seeking.\n     *\n     * @return {GetSeekingPromise}\n     */\n\n  }, {\n    key: \"getSeeking\",\n    value: function getSeeking() {\n      return this.get('seeking');\n    }\n    /**\n     * A promise to get the text tracks of a video.\n     *\n     * @promise GetTextTracksPromise\n     * @fulfill {VimeoTextTrack[]} The text tracks associated with the video.\n     */\n\n    /**\n     * Get an array of the text tracks that exist for the video.\n     *\n     * @return {GetTextTracksPromise}\n     */\n\n  }, {\n    key: \"getTextTracks\",\n    value: function getTextTracks() {\n      return this.get('textTracks');\n    }\n    /**\n     * A promise to get the embed code for the video.\n     *\n     * @promise GetVideoEmbedCodePromise\n     * @fulfill {string} The `<iframe>` embed code for the video.\n     */\n\n    /**\n     * Get the `<iframe>` embed code for the video.\n     *\n     * @return {GetVideoEmbedCodePromise}\n     */\n\n  }, {\n    key: \"getVideoEmbedCode\",\n    value: function getVideoEmbedCode() {\n      return this.get('videoEmbedCode');\n    }\n    /**\n     * A promise to get the id of the video.\n     *\n     * @promise GetVideoIdPromise\n     * @fulfill {number} The id of the video.\n     */\n\n    /**\n     * Get the id of the video.\n     *\n     * @return {GetVideoIdPromise}\n     */\n\n  }, {\n    key: \"getVideoId\",\n    value: function getVideoId() {\n      return this.get('videoId');\n    }\n    /**\n     * A promise to get the title of the video.\n     *\n     * @promise GetVideoTitlePromise\n     * @fulfill {number} The title of the video.\n     */\n\n    /**\n     * Get the title of the video.\n     *\n     * @return {GetVideoTitlePromise}\n     */\n\n  }, {\n    key: \"getVideoTitle\",\n    value: function getVideoTitle() {\n      return this.get('videoTitle');\n    }\n    /**\n     * A promise to get the native width of the video.\n     *\n     * @promise GetVideoWidthPromise\n     * @fulfill {number} The native width of the video.\n     */\n\n    /**\n     * Get the native width of the currentlyplaying video. The width of\n     * the highestresolution available will be used before playback begins.\n     *\n     * @return {GetVideoWidthPromise}\n     */\n\n  }, {\n    key: \"getVideoWidth\",\n    value: function getVideoWidth() {\n      return this.get('videoWidth');\n    }\n    /**\n     * A promise to get the native height of the video.\n     *\n     * @promise GetVideoHeightPromise\n     * @fulfill {number} The native height of the video.\n     */\n\n    /**\n     * Get the native height of the currentlyplaying video. The height of\n     * the highestresolution available will be used before playback begins.\n     *\n     * @return {GetVideoHeightPromise}\n     */\n\n  }, {\n    key: \"getVideoHeight\",\n    value: function getVideoHeight() {\n      return this.get('videoHeight');\n    }\n    /**\n     * A promise to get the vimeo.com url for the video.\n     *\n     * @promise GetVideoUrlPromise\n     * @fulfill {number} The vimeo.com url for the video.\n     * @reject {PrivacyError} The url isnt available because of the videos privacy setting.\n     */\n\n    /**\n     * Get the vimeo.com url for the video.\n     *\n     * @return {GetVideoUrlPromise}\n     */\n\n  }, {\n    key: \"getVideoUrl\",\n    value: function getVideoUrl() {\n      return this.get('videoUrl');\n    }\n    /**\n     * A promise to get the volume level of the player.\n     *\n     * @promise GetVolumePromise\n     * @fulfill {number} The volume level of the player on a scale from 0 to 1.\n     */\n\n    /**\n     * Get the current volume level of the player on a scale from `0` to `1`.\n     *\n     * Most mobile devices do not support an independent volume from the\n     * system volume. In those cases, this method will always return `1`.\n     *\n     * @return {GetVolumePromise}\n     */\n\n  }, {\n    key: \"getVolume\",\n    value: function getVolume() {\n      return this.get('volume');\n    }\n    /**\n     * A promise to set the volume level of the player.\n     *\n     * @promise SetVolumePromise\n     * @fulfill {number} The volume was set.\n     * @reject {RangeError} The volume was less than 0 or greater than 1.\n     */\n\n    /**\n     * Set the volume of the player on a scale from `0` to `1`. When set\n     * via the API, the volume level will not be synchronized to other\n     * players or stored as the viewers preference.\n     *\n     * Most mobile devices do not support setting the volume. An error will\n     * *not* be triggered in that situation.\n     *\n     * @param {number} volume\n     * @return {SetVolumePromise}\n     */\n\n  }, {\n    key: \"setVolume\",\n    value: function setVolume(volume) {\n      return this.set('volume', volume);\n    }\n  }]);\n\n  return Player;\n}(); // Setup embed only if this is not a node environment\n\n\nif (!isNode) {\n  screenfull = initializeScreenfull();\n  initializeEmbeds();\n  resizeEmbeds();\n  initAppendVideoMetadata();\n}\n\nexport default Player;\n","import { assign, clamp } from '@splidejs/splide/src/js/utils';\r\nimport Vimeo from '@vimeo/player';\r\nimport { AbstractVideoPlayer } from '../../classes/AbstractVideoPlayer';\r\nimport { IDLE, INITIALIZED, PLAY_REQUEST_ABORTED } from '../../constants/states';\r\nimport { VideoOptions } from '../../types/options';\r\n\r\n\r\n/**\r\n * The wrapper class for the Vimeo player.\r\n *\r\n * @since 0.5.0\r\n */\r\nexport class VimeoPlayer extends AbstractVideoPlayer<Vimeo> {\r\n  /**\r\n   * The VimeoPlayer constructor.\r\n   *\r\n   * @param target  - A target element where the player is mounted.\r\n   * @param videoId - A video ID or an URL itself.\r\n   * @param options - Optional. Options.\r\n   */\r\n  constructor( target: HTMLElement, videoId: string, options: VideoOptions = {} ) {\r\n    super( target, videoId, options );\r\n    this.state.set( INITIALIZED );\r\n  }\r\n\r\n  /**\r\n   * Creates a player.\r\n   * The `hideControls` option now only work for PRO users.\r\n   * Note that passing null/undefined can not disable each option.\r\n   *\r\n   * @param videoId - Optional. A video ID or an URL.\r\n   *\r\n   * @return A Vimeo player instance.\r\n   */\r\n  protected createPlayer( videoId: string ): Vimeo {\r\n    const { options, options: { playerOptions = {} } } = this;\r\n    const vimeoOptions = videoId.indexOf( 'http' ) === 0 ? { url: videoId } : { id: +videoId };\r\n\r\n    const player = new Vimeo( this.target, assign( vimeoOptions, {\r\n      controls: ! options.hideControls,\r\n      loop    : options.loop,\r\n      muted   : options.mute,\r\n    }, playerOptions.vimeo || {} ) );\r\n\r\n    player.on( 'play', this.onPlay );\r\n    player.on( 'pause', this.onPause );\r\n    player.on( 'ended', this.onEnded );\r\n    player.ready().then( this.onPlayerReady, this.onError );\r\n\r\n    if ( ! player.getMuted() ) {\r\n      player.setVolume( clamp( options.volume, 0, 1 ) );\r\n    }\r\n\r\n    return player;\r\n  }\r\n\r\n  /**\r\n   * Starts the video.\r\n   */\r\n  protected playVideo(): void {\r\n    this.player.play().catch( () => {\r\n      if ( this.state.is( PLAY_REQUEST_ABORTED ) ) {\r\n        this.state.set( IDLE );\r\n      }\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Pauses the video.\r\n   */\r\n  protected pauseVideo(): void {\r\n    this.player.pause();\r\n  }\r\n}\r\n","import { isUndefined, queryAll, create, isFunction } from '@splidejs/splide/src/js/utils';\r\n\r\n\r\n/**\r\n * Let the compiler understand the callback function.\r\n */\r\ndeclare global {\r\n  interface Window {\r\n    onYouTubeIframeAPIReady: () => void;\r\n  }\r\n}\r\n\r\n/**\r\n * The URL to the YouTube iframe API script.\r\n * The protocol will be prepended later.\r\n *\r\n * @since 0.5.0\r\n */\r\nconst YOUTUBE_API_SRC = '//www.youtube.com/player_api';\r\n\r\n/**\r\n * The class for loading the YouTube API script.\r\n *\r\n * @link https://developers.google.com/youtube/iframe_api_reference\r\n *\r\n * @since 0.5.0\r\n */\r\nexport class YouTubeIframeAPILoader {\r\n  /**\r\n   * Starts loading the YouTube API script.\r\n   *\r\n   * @param callback - A callback function that will be invoked when the API is ready.\r\n   */\r\n  load( callback: () => void ): void {\r\n    if ( window.YT && isFunction( window.YT.Player ) ) {\r\n      return callback();\r\n    }\r\n\r\n    this.attachCallback( callback );\r\n\r\n    if ( this.shouldLoad() ) {\r\n      create( 'script', { src: `${ location.protocol }${ YOUTUBE_API_SRC }` }, document.head );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the new script tag for the YouTube API should be injected or not.\r\n   *\r\n   * @return `true` if the API should be loaded.\r\n   */\r\n  private shouldLoad(): boolean {\r\n    return ! queryAll<HTMLScriptElement>( document, 'script' )\r\n      .some( script => script.src.replace( /^https?:/, '' ) === YOUTUBE_API_SRC );\r\n  }\r\n\r\n  /**\r\n   * Attaches the callback function that will be invoked when the API is ready.\r\n   *\r\n   * @param callback - A callback function to invoke.\r\n   */\r\n  private attachCallback( callback: () => void ): void {\r\n    let oldCallback: () => void;\r\n\r\n    if ( ! isUndefined( window.onYouTubeIframeAPIReady ) ) {\r\n      oldCallback = window.onYouTubeIframeAPIReady;\r\n    }\r\n\r\n    window.onYouTubeIframeAPIReady = () => {\r\n      oldCallback && oldCallback();\r\n      callback();\r\n    };\r\n  }\r\n}\r\n","import { assign, find, clamp } from '@splidejs/splide/src/js/utils';\r\nimport { AbstractVideoPlayer } from '../../classes/AbstractVideoPlayer';\r\nimport { INITIALIZED, INITIALIZING, PENDING_PLAY } from '../../constants/states';\r\nimport { VideoOptions } from '../../types/options';\r\nimport { YouTubeIframeAPILoader } from './YouTubeIframeAPILoader';\r\n\r\n\r\n/**\r\n * The wrapper class for the YouTube player.\r\n *\r\n * @since 0.5.0\r\n */\r\nexport class YouTubePlayer extends AbstractVideoPlayer<YT.Player> {\r\n  /**\r\n   * The YouTubePlayer constructor.\r\n   *\r\n   * @param target  - A target element where the player is mounted.\r\n   * @param videoId - A video ID or an URL itself.\r\n   * @param options - Optional. Options.\r\n   */\r\n  constructor( target: HTMLElement, videoId: string, options: VideoOptions = {} ) {\r\n    super( target, videoId, options );\r\n\r\n    this.videoId = this.parseVideoId( videoId );\r\n\r\n    if ( this.videoId ) {\r\n      this.state.set( INITIALIZING );\r\n      new YouTubeIframeAPILoader().load( this.onAPIReady.bind( this ) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the YouTube iframe API is ready.\r\n   */\r\n  private onAPIReady(): void {\r\n    const { state } = this;\r\n    const isPending = state.is( PENDING_PLAY );\r\n\r\n    state.set( INITIALIZED );\r\n\r\n    if ( isPending ) {\r\n      this.play();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a player.\r\n   * Note that the `loop` does not work without the `playlist` parameter.\r\n   *\r\n   * @link https://developers.google.com/youtube/player_parameters\r\n   *\r\n   * @param videoId - Optional. A video ID.\r\n   *\r\n   * @return A YT.Player instance.\r\n   */\r\n  protected createPlayer( videoId: string ): YT.Player {\r\n    const { options, options: { playerOptions = {} } } = this;\r\n\r\n    return new YT.Player( this.target, {\r\n      videoId,\r\n      host: options.host,\r\n      playerVars: assign( {\r\n        controls      : options.hideControls ? 0 : 1,\r\n        iv_load_policy: 3, // eslint-disable-line camelcase\r\n        loop          : options.loop ? 1 : 0,\r\n        playlist      : options.loop ? videoId : undefined,\r\n        rel           : 0,\r\n        autoplay      : 0,\r\n        mute          : options.mute ? 1 : 0,\r\n      }, playerOptions.youtube || {} ),\r\n      events: {\r\n        onReady      : this.onPlayerReady.bind( this ),\r\n        onStateChange: this.onPlayerStateChange.bind( this ),\r\n        onError      : this.onError.bind( this ),\r\n      },\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Called when the player becomes ready.\r\n   */\r\n  protected onPlayerReady(): void {\r\n    super.onPlayerReady();\r\n    this.player.setVolume( clamp( this.options.volume, 0, 1 ) * 100 );\r\n  }\r\n\r\n  /**\r\n   * Called when the YouTube player state is changed.\r\n   *\r\n   * @param e - A YT.OnStateChangeEvent object.\r\n   */\r\n  private onPlayerStateChange( e: YT.OnStateChangeEvent ): void {\r\n    const { PLAYING, PAUSED, ENDED } = YT.PlayerState;\r\n\r\n    switch ( true ) {\r\n      case e.data === PLAYING:\r\n        this.onPlay();\r\n        break;\r\n\r\n      case e.data === PAUSED:\r\n        this.onPause();\r\n        break;\r\n\r\n      case e.data === ENDED:\r\n        this.onEnded();\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts the video.\r\n   */\r\n  protected playVideo(): void {\r\n    this.player.playVideo();\r\n  }\r\n\r\n  /**\r\n   * Pauses the video.\r\n   */\r\n  protected pauseVideo(): void {\r\n    this.player.pauseVideo();\r\n  }\r\n\r\n  /**\r\n   * Parses the video ID.\r\n   * If it is an URL, plucks the ID from it.\r\n   *\r\n   * @param id - An ID to parse.\r\n   *\r\n   * @return A video ID if available, or otherwise `undefined`.\r\n   */\r\n  private parseVideoId( id: string ): string | undefined {\r\n    return id.indexOf( 'http' ) === 0 ? this.parseUrl( id ) : id;\r\n  }\r\n\r\n  /**\r\n   * Plucks the ID from the provided URL.\r\n   *\r\n   * @param url - An URL to parse.\r\n   *\r\n   * @return A video ID if available, or otherwise `undefined`.\r\n   */\r\n  private parseUrl( url: string ): string | undefined {\r\n    const [ , search ] = url.split( /[#?]/ );\r\n    const query = find( search.split( '&' ), query => query.indexOf( 'v=' ) === 0 );\r\n    return query && query.replace( 'v=', '' );\r\n  }\r\n}\r\n","/**\r\n * The collection of i18n strings.\r\n *\r\n * @since 0.5.0\r\n */\r\nexport const I18N = {\r\n  playVideo: 'Play Video',\r\n};\r\n","import { AnyFunction, CLASS_CONTAINER, CLASS_SLIDE, EventInterface, Splide } from '@splidejs/splide';\r\nimport { I18N } from '../constants/i18n';\r\nimport { addClass, child, create, display, remove, removeClass } from '@splidejs/splide/src/js/utils';\r\nimport { CLASS_VIDEO, CLASS_VIDEO_PLAY_BUTTON, CLASS_VIDEO_WRAPPER, MODIFIER_HAS_VIDEO } from '../constants/classes';\r\n\r\n\r\n/**\r\n * The class for the UI of the video player.\r\n *\r\n * @since 0.5.0\r\n */\r\nexport class PlayerUI {\r\n  /**\r\n   * The Splide instance.\r\n   */\r\n  private Splide: Splide;\r\n\r\n  /**\r\n   * The slide element.\r\n   */\r\n  private readonly slide: HTMLElement;\r\n\r\n  /**\r\n   * The parent element of the video, which may be the slide or the container element.\r\n   */\r\n  private readonly parent: HTMLElement;\r\n\r\n  /**\r\n   * Holds the container element if available.\r\n   */\r\n  private readonly container: HTMLElement | undefined;\r\n\r\n  /**\r\n   * The EventBus object.\r\n   */\r\n  private readonly event = EventInterface();\r\n\r\n  /**\r\n   * Indicates whether the UI is disabled or not.\r\n   */\r\n  private disabled: boolean;\r\n\r\n  /**\r\n   * The wrapper element that contains the wrapper and the play button.\r\n   */\r\n  private video: HTMLDivElement;\r\n\r\n  /**\r\n   * The wrapper element that contains the video.\r\n   */\r\n  private wrapper: HTMLDivElement;\r\n\r\n  /**\r\n   * The placeholder element.\r\n   * - YouTube  : Will replace this element by an iframe\r\n   * - Vimeo    : Will append an iframe to this\r\n   * - HTMLVideo: Will append an video element to this\r\n   */\r\n  private placeholder: HTMLDivElement;\r\n\r\n  /**\r\n   * The button element for play.\r\n   */\r\n  private playButton: HTMLButtonElement;\r\n\r\n  /**\r\n   * The PlayerUI constructor.\r\n   *\r\n   * @param Splide - A Splide instance.\r\n   * @param slide  - A slide element where the player is mounted.\r\n   */\r\n  constructor( Splide: Splide, slide: HTMLElement ) {\r\n    this.Splide    = Splide;\r\n    this.slide     = slide;\r\n    this.container = child( this.slide, `.${ CLASS_CONTAINER }` );\r\n    this.parent    = this.container || this.slide;\r\n\r\n    this.init();\r\n    this.create();\r\n    this.show();\r\n    this.listen();\r\n  }\r\n\r\n  /**\r\n   * Initializes the instance.\r\n   */\r\n  private init(): void {\r\n    addClass( this.slide, `${ CLASS_SLIDE }${ MODIFIER_HAS_VIDEO }` );\r\n    addClass( this.container, `${ CLASS_CONTAINER }${ MODIFIER_HAS_VIDEO }` );\r\n  }\r\n\r\n  /**\r\n   * Creates wrapper, placeholder and button elements.\r\n   * Make sure that the button element must be rendered before the wrapper for the proper focus order.\r\n   */\r\n  private create(): void {\r\n    this.video = create( 'div', CLASS_VIDEO, this.parent );\r\n\r\n    this.playButton = create( 'button', {\r\n      class       : CLASS_VIDEO_PLAY_BUTTON,\r\n      type        : 'button',\r\n      'aria-label': this.Splide.options.i18n.playVideo || I18N.playVideo,\r\n    }, this.video );\r\n\r\n    this.wrapper     = create( 'div', CLASS_VIDEO_WRAPPER, this.video );\r\n    this.placeholder = create( 'div', null, this.wrapper );\r\n  }\r\n\r\n  /**\r\n   * Listens to some events.\r\n   */\r\n  private listen(): void {\r\n    this.parent.addEventListener( 'click', () => {\r\n      this.event.emit( 'click' );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Toggles the play button.\r\n   *\r\n   * @param show - Determines whether to show or hide the button.\r\n   */\r\n  private toggleButton( show?: boolean ): void {\r\n    display( this.playButton, show ? '' : 'none' );\r\n  }\r\n\r\n  /**\r\n   * Toggles the wrapper element.\r\n   *\r\n   * @param show - Determines whether to show or hide the button.\r\n   */\r\n  private toggleWrapper( show?: boolean ): void {\r\n    display( this.wrapper, show ? '' : 'none' );\r\n  }\r\n\r\n  /**\r\n   * Returns the placeholder element.\r\n   */\r\n  getPlaceholder(): HTMLDivElement {\r\n    return this.placeholder;\r\n  }\r\n\r\n  /**\r\n   * Hides UI and displays the video.\r\n   */\r\n  hide(): void {\r\n    this.toggleButton( false );\r\n    this.toggleWrapper( true );\r\n  }\r\n\r\n  /**\r\n   * Displays UI and hides the video.\r\n   */\r\n  show(): void {\r\n    if ( ! this.disabled ) {\r\n      this.toggleButton( true );\r\n    }\r\n\r\n    this.toggleWrapper( false );\r\n  }\r\n\r\n  /**\r\n   * Disables UI (the play button) displays on the slide.\r\n   *\r\n   * @param disabled - Determines whether to disable UI or not.\r\n   */\r\n  disable( disabled: boolean ): void {\r\n    this.disabled = disabled;\r\n\r\n    if ( disabled ) {\r\n      this.toggleButton( false );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attaches an event handler.\r\n   *\r\n   * @param events   - An event or events.\r\n   * @param callback - A callback function.\r\n   */\r\n  on( events: string | string[], callback: AnyFunction ): void {\r\n    this.event.on( events, callback );\r\n  }\r\n\r\n  /**\r\n   * Destroys the instance.\r\n   */\r\n  destroy(): void {\r\n    removeClass( this.slide, `${ CLASS_SLIDE }${ MODIFIER_HAS_VIDEO }` );\r\n    removeClass( this.container, `${ CLASS_CONTAINER }${ MODIFIER_HAS_VIDEO }` );\r\n    remove( this.video );\r\n    this.event.destroy();\r\n  }\r\n}\r\n","import {\r\n  EVENT_DRAG,\r\n  EVENT_DRAGGING,\r\n  EVENT_MOUNTED,\r\n  EVENT_MOVE,\r\n  EVENT_MOVED,\r\n  EVENT_SCROLL,\r\n  EVENT_SCROLLED,\r\n  EventInterface,\r\n  EventInterfaceObject,\r\n  Splide,\r\n} from '@splidejs/splide';\r\nimport { addClass, getAttribute, merge, toggleClass } from '@splidejs/splide/src/js/utils';\r\nimport { CLASS_ERROR, CLASS_PLAYING, CLASS_VIDEO_DISABLED } from '../constants/classes';\r\nimport { HTML_VIDEO__DATA_ATTRIBUTE, VIMEO_DATA_ATTRIBUTE, YOUTUBE_DATA_ATTRIBUTE } from '../constants/data-attributes';\r\nimport { DEFAULTS } from '../constants/defaults';\r\nimport {\r\n  EVENT_VIDEO_CLICK,\r\n  EVENT_VIDEO_ENDED,\r\n  EVENT_VIDEO_ERROR,\r\n  EVENT_VIDEO_PAUSE,\r\n  EVENT_VIDEO_PLAY,\r\n} from '../constants/events';\r\nimport { HTMLVideoPlayer } from '../players/html/HTMLVideoPlayer';\r\nimport { VimeoPlayer } from '../players/vimeo/VimeoPlayer';\r\nimport { YouTubePlayer } from '../players/youtube/YouTubePlayer';\r\nimport { VideoPlayerConstructor, VideoPlayerInterface } from '../types/general';\r\nimport { VideoOptions } from '../types/options';\r\nimport { PlayerUI } from './PlayerUI';\r\n\r\n\r\n/**\r\n * Associates the data attribute name with the player constructor.\r\n *\r\n * @since 0.5.0\r\n */\r\nconst VIDEO_PLAYER_MAP: Array<[ string, VideoPlayerConstructor ]> = [\r\n  [ YOUTUBE_DATA_ATTRIBUTE, YouTubePlayer ],\r\n  [ VIMEO_DATA_ATTRIBUTE, VimeoPlayer ],\r\n  [ HTML_VIDEO__DATA_ATTRIBUTE, HTMLVideoPlayer ],\r\n];\r\n\r\n/**\r\n * The class for the video player that connects a Splide slide with PlayerUI and VideoPlayer instances.\r\n *\r\n * @since 0.5.0\r\n */\r\nexport class Player {\r\n  /**\r\n   * The Splide instance.\r\n   */\r\n  private readonly Splide: Splide;\r\n\r\n  /**\r\n   * The slide element.\r\n   */\r\n  private readonly slide: HTMLElement;\r\n\r\n  /**\r\n   * Video options.\r\n   */\r\n  private readonly options: VideoOptions;\r\n\r\n  /**\r\n   * The PlayerUI instance.\r\n   */\r\n  private ui: PlayerUI;\r\n\r\n  /**\r\n   * The VideoPlayer instance.\r\n   */\r\n  private player: VideoPlayerInterface;\r\n\r\n  /**\r\n   * The EventInterface object.\r\n   */\r\n  private event: EventInterfaceObject;\r\n\r\n  /**\r\n   * Indicates whether the player is disabled or not.\r\n   */\r\n  private disabled: boolean;\r\n\r\n  /**\r\n   * The Player constructor.\r\n   *\r\n   * @param Splide - A Splide instance.\r\n   * @param slide  - A slide element where the player is applied.\r\n   */\r\n  constructor( Splide: Splide, slide: HTMLElement ) {\r\n    this.Splide  = Splide;\r\n    this.slide   = slide;\r\n    this.event   = EventInterface( Splide );\r\n    this.options = merge( merge( {}, DEFAULTS ), this.Splide.options.video );\r\n\r\n    this.createPlayer( slide );\r\n\r\n    if ( this.player ) {\r\n      this.listen();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a Player.\r\n   * This will fail when the slide element does not have the data attribute for the video.\r\n   *\r\n   * @param slide - A slide element.\r\n   */\r\n  private createPlayer( slide: HTMLElement ): void {\r\n    VIDEO_PLAYER_MAP.forEach( ( [ attr, Constructor ] ) => {\r\n      const id = getAttribute( slide, attr );\r\n\r\n      if ( id ) {\r\n        this.ui     = new PlayerUI( this.Splide, slide );\r\n        this.player = new Constructor( this.ui.getPlaceholder(), id, this.options );\r\n        this.ui.disable( this.options.disableOverlayUI );\r\n      }\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Listens to UI, VideoPlayer and Splide events.\r\n   */\r\n  private listen(): void {\r\n    const { player, event } = this;\r\n\r\n    this.ui.on( 'click', this.onClick.bind( this ) );\r\n\r\n    player.on( 'play', this.onPlay.bind( this ) );\r\n    player.on( 'played', this.onPlayed.bind( this ) );\r\n    player.on( 'pause', this.onPause.bind( this ) );\r\n    player.on( 'paused', this.onPaused.bind( this ) );\r\n    player.on( 'ended', this.onEnded.bind( this ) );\r\n    player.on( 'error', this.onError.bind( this ) );\r\n\r\n    event.on( [ EVENT_MOVE, EVENT_SCROLL ], this.pause.bind( this ) );\r\n    event.on( EVENT_VIDEO_CLICK, this.onVideoClick.bind( this ) );\r\n\r\n    event.on( EVENT_DRAG, () => {\r\n      event.off( EVENT_DRAGGING );\r\n      event.on( EVENT_DRAGGING, () => {\r\n        this.pause();\r\n        event.off( EVENT_DRAGGING );\r\n      } );\r\n    } );\r\n\r\n    if ( this.options.autoplay ) {\r\n      event.on( [ EVENT_MOUNTED, EVENT_MOVED, EVENT_SCROLLED ], this.onAutoplayRequested.bind( this ) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the slide element is clicked.\r\n   */\r\n  private onClick(): void {\r\n    this.isPaused() ? this.play() : this.pause();\r\n    this.event.emit( EVENT_VIDEO_CLICK, this );\r\n  }\r\n\r\n  /**\r\n   * Called when any slides that have a video are clicked.\r\n   *\r\n   * @param player - A player instance that the clicked slide has.\r\n   */\r\n  private onVideoClick( player: Player ): void {\r\n    if ( this !== player ) {\r\n      this.pause();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the video is requested to start.\r\n   * The video may be loading at this moment.\r\n   */\r\n  private onPlay(): void {\r\n    this.ui.hide();\r\n  }\r\n\r\n  /**\r\n   * Called when the video begins.\r\n   */\r\n  private onPlayed(): void {\r\n    this.ui.hide();\r\n    this.togglePlaying( true );\r\n    this.event.emit( EVENT_VIDEO_PLAY, this );\r\n  }\r\n\r\n  /**\r\n   * Called when the video is requested to pause.\r\n   */\r\n  private onPause(): void {\r\n    this.ui.show();\r\n  }\r\n\r\n  /**\r\n   * Called when the video is paused.\r\n   */\r\n  private onPaused(): void {\r\n    this.togglePlaying( false );\r\n    this.event.emit( EVENT_VIDEO_PAUSE, this );\r\n  }\r\n\r\n  /**\r\n   * Called when the video ends.\r\n   */\r\n  private onEnded(): void {\r\n    this.togglePlaying( false );\r\n    this.event.emit( EVENT_VIDEO_ENDED, this );\r\n  }\r\n\r\n  /**\r\n   * Called when an error occurs.\r\n   */\r\n  private onError(): void {\r\n    addClass( this.slide, CLASS_ERROR );\r\n    this.ui.show();\r\n    this.event.emit( EVENT_VIDEO_ERROR, this );\r\n  }\r\n\r\n  /**\r\n   * Called when the autoplay option is `true` and the slider should start the video.\r\n   */\r\n  private onAutoplayRequested(): void {\r\n    const activeSlide = this.Splide.Components.Slides.getAt( this.Splide.index );\r\n\r\n    if ( activeSlide.slide === this.slide ) {\r\n      this.play();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggles the playing status class.\r\n   *\r\n   * @param add - Determines whether to add or remove the class.\r\n   */\r\n  private togglePlaying( add: boolean ): void {\r\n    toggleClass( this.Splide.root, CLASS_PLAYING, add );\r\n  }\r\n\r\n  /**\r\n   * Starts the video.\r\n   */\r\n  play(): void {\r\n    if ( this.player && ! this.disabled ) {\r\n      this.player.play();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pauses the video.\r\n   */\r\n  pause(): void {\r\n    if ( this.player && ! this.disabled ) {\r\n      this.player.pause();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the instance.\r\n   */\r\n  destroy(): void {\r\n    if ( this.player ) {\r\n      this.ui.destroy();\r\n      this.player.destroy();\r\n    }\r\n\r\n    this.disable( false );\r\n  }\r\n\r\n  /**\r\n   * Disables the play/pause control.\r\n   */\r\n  disable( disabled: boolean ): void {\r\n    this.disabled = disabled;\r\n    toggleClass( this.Splide.root, CLASS_VIDEO_DISABLED, disabled );\r\n  }\r\n\r\n  /**\r\n   * Checks if the video is paused or not.\r\n   *\r\n   * @return `true` if the video is paused.\r\n   */\r\n  isPaused(): boolean {\r\n    return this.player.isPaused();\r\n  }\r\n}\r\n","export const YOUTUBE_DATA_ATTRIBUTE = 'data-splide-youtube';\r\nexport const VIMEO_DATA_ATTRIBUTE = 'data-splide-vimeo';\r\nexport const HTML_VIDEO__DATA_ATTRIBUTE = 'data-splide-html-video';\r\n","import { Video } from '../extensions';\r\n\r\n\r\ndeclare global {\r\n  interface Window {\r\n    splide: Record<string, any>;\r\n  }\r\n}\r\n\r\nif ( typeof window !== 'undefined' ) {\r\n  window.splide = window.splide || {};\r\n  window.splide.Extensions = window.splide.Extensions || {};\r\n  window.splide.Extensions.Video = Video;\r\n}\r\n","import { BaseComponent, CLASS_SLIDE, Components, EventInterface, Splide } from '@splidejs/splide';\r\nimport { forOwn, hasClass } from '@splidejs/splide/src/js/utils';\r\nimport { Player } from '../../classes/Player';\r\nimport { VideoOptions } from '../../types/options';\r\nimport { MODIFIER_HAS_VIDEO } from \"../../constants/classes\";\r\n\r\n\r\n/**\r\n * Lets the compiler know the type of video options.\r\n */\r\ndeclare module '@splidejs/splide' {\r\n  interface Options {\r\n    video?: VideoOptions;\r\n  }\r\n\r\n  interface Components {\r\n    Video?: VideoComponent;\r\n  }\r\n}\r\n\r\n/**\r\n * The interface for the Video component.\r\n *\r\n * @since 0.5.3\r\n */\r\nexport interface VideoComponent extends BaseComponent {\r\n  play( index?: number ): void;\r\n  pause(): void;\r\n  disable( disabled: boolean ): void;\r\n}\r\n\r\n/**\r\n * The extension for embedding videos to slides.\r\n *\r\n * @since 0.5.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n *\r\n * @return A Video component object.\r\n */\r\nexport function Video( Splide: Splide, Components: Components ): VideoComponent {\r\n  const { on } = EventInterface( Splide );\r\n  const { Slides } = Components;\r\n\r\n  /**\r\n   * Stores Player instances.\r\n   */\r\n  const players: Record<number, Player> = {};\r\n\r\n  /**\r\n   * Called when the extension is mounted.\r\n   * When detecting the refresh event, creates players for non-initialized slides.\r\n   */\r\n  function mount(): void {\r\n    create();\r\n    on( 'refresh', create );\r\n  }\r\n\r\n  /**\r\n   * Creates players for slides that have not been initialized.\r\n   * Needs to call `update()` for attributes related with accessibility.\r\n   */\r\n  function create(): void {\r\n    Slides.forEach( Slide => {\r\n      const { slide } = Slide;\r\n\r\n      if ( ! hasClass( slide, `${ CLASS_SLIDE }${ MODIFIER_HAS_VIDEO }` ) ) {\r\n        players[ Slide.index ] = new Player( Splide, slide );\r\n      }\r\n    } );\r\n\r\n    Slides.update();\r\n  }\r\n\r\n  /**\r\n   * Destroys the extension.\r\n   */\r\n  function destroy(): void {\r\n    forOwn( players, player => {\r\n      player.destroy();\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Plays the video at the active or specified index.\r\n   *\r\n   * @param index - A slide index.\r\n   */\r\n  function play( index = Splide.index ): void {\r\n    const player = players[ index ];\r\n\r\n    if ( player ) {\r\n      player.play();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pauses the playing video.\r\n   */\r\n  function pause(): void {\r\n    forOwn( players, player => {\r\n      player.pause();\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Disables play/pause.\r\n   *\r\n   * @param disabled - Set `true` for disabling the play/pause control.\r\n   */\r\n  function disable( disabled: boolean ): void {\r\n    forOwn( players, player => {\r\n      player.disable( disabled );\r\n    } );\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy,\r\n    play,\r\n    pause,\r\n    disable,\r\n  };\r\n}\r\n"],"names":["slice","arrayLike","start","end","Array","prototype","call","apply","func","bind","concat","arguments","typeOf","type","subject","isArray","toArray","value","forEach","values","iteratee","ownKeys","Object","keys","forOwn","object","right","reverse","i","length","key","EVENT_DRAGGING","EventInterface","Splide2","bus","event","document","createDocumentFragment","binder","listeners","forEachEvent","targets","events","target","events2","split","eventNS","fragment","callback","options","namespace","isEventTarget","remover","removeEventListener","addEventListener","push","unbind","filter","listener","dispatch","detail","e","CustomEvent","bubbles","createEvent","initCustomEvent","dispatchEvent","destroy","data","EventBinder","on","source","assign","join","off","emit","CLASS_SLIDE","PROJECT_CODE","CLASS_CONTAINER","isObject","isNull","isFunction","isString","isUndefined","toggleClass","elm","classes","add","name","classList","addClass","matches","selector","HTMLElement","child","parent","children2","children","firstElementChild","merge","setAttribute","elms","attrs","value2","attr","removeAttribute","String","create","tag","createElement","appendChild","append","display","display2","prop","getComputedStyle","style","removeClass","min","Math","max","clamp","number","x","y","minimum","maximum","floor","ceil","abs","CLASS_VIDEO","CLASS_VIDEO_WRAPPER","CLASS_VIDEO_PLAY_BUTTON","MODIFIER_HAS_VIDEO","DEFAULTS","hideControls","loop","mute","volume","EVENT_VIDEO_CLICK","AbstractVideoPlayer","videoId","state","this","set","is","states","array","indexOf","onPlay","onPause","onEnded","onPlayerReady","onError","play","message","console","error","player","createPlayer","playVideo","pause","pauseVideo","isPaused","isPending","aborted","HTMLVideoPlayer","_this6","_AbstractVideoPlayer","_this$options$playerO","playerOptions","src","controls","muted","htmlVideo","promise","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","isNode","global","toString","getMethodName","toLowerCase","substr","toUpperCase","isDomElement","element","Boolean","nodeType","ownerDocument","defaultView","isInteger","isNaN","parseFloat","isFinite","isVimeoUrl","url","test","isVimeoEmbed","getVimeoUrl","oEmbedParameters","undefined","id","idOrUrl","Error","replace","arrayIndexOfSupport","postMessageSupport","window","postMessage","commonjsGlobal","globalThis","self","WeakMap","hasOwnProperty","hasDefine","genId","checkInstance","methodName","prefix","rand","random","substring","entry","_id","fn","module","npo_src","context","definition","builtInProp","cycle","scheduling_queue","ToString","timer","setImmediate","setTimeout","obj","val","config","err","schedule","drain","isThenable","o","_then","o_type","then","notify","chain","notifyIsolated","success","failure","cb","ret","reject","msg","resolve","triggered","def","def_wrapper","MakeDefWrapper","iteratePromises","arr","resolver","rejecter","idx","MakeDef","Promise","executor","__NPO__","constructor","first","last","item","Item","next","f","PromisePrototype","len","msgs","count","exports","callbackMap","storeCallback","playerCallbacks","get","getCallbacks","removeCallback","index","splice","swapCallbacks","oldElement","newElement","parseMessageData","JSON","parse","warn","method","params","contentWindow","ieVersion","navigator","userAgent","stringify","origin","processData","param","callbacks","shift","shiftCallbacks","getOEmbedParameters","defaults","reduce","getAttribute","createEmbed","_ref","html","querySelector","div","innerHTML","firstChild","getOEmbedData","videoUrl","encodeURIComponent","xhr","XDomainRequest","XMLHttpRequest","open","onload","status","json","responseText","domain_status_code","onerror","send","playerMap","readyMap","screenfull","Player","_this","jQuery","getElementById","nodeName","iframe","has","_window","readyPromise","_onMessage","isReadyEvent","isPingResponse","_originalElement","isEnabled","exitFullscreen","exit","fullscreenchangeHandler","isFullscreen","ready","protoProps","staticProps","_this2","args","_this3","_this4","eventName","callMethod","time","language","kind","request","_this5","parentNode","removeChild","autopause","camera","color","currentTime","playbackRate","quality","fnMap","l","eventNameMap","fullscreenchange","fullscreenerror","onFullScreenEntered","returnPromise","documentElement","requestFullscreen","onFullScreenExit","defineProperties","fullscreenElement","fullscreenEnabled","initializeScreenfull","elements","querySelectorAll","handleError","initializeEmbeds","VimeoPlayerResizeEmbeds_","onMessage","iframes","parentElement","paddingBottom","bottom","resizeEmbeds","VimeoSeoMetadataAppended","isValidMessageSource","location","href","initAppendVideoMetadata","VimeoPlayer","_this7","_AbstractVideoPlayer2","_this$options$playerO2","vimeoOptions","Vimeo","vimeo","getMuted","setVolume","_this8","YOUTUBE_API_SRC","YouTubeIframeAPILoader","load","YT","attachCallback","shouldLoad","protocol","head","some","script","oldCallback","onYouTubeIframeAPIReady","YouTubePlayer","_this9","_AbstractVideoPlayer3","parseVideoId","onAPIReady","$904e467639ab9b04$var$_assertThisInitialized","_this$options$playerO3","host","playerVars","iv_load_policy","playlist","rel","autoplay","youtube","onReady","onStateChange","onPlayerStateChange","_YT$PlayerState","PlayerState","PLAYING","PAUSED","ENDED","parseUrl","predicate","search","query","I18N","PlayerUI","Splide","slide","container","init","show","listen","video","playButton","class","i18n","wrapper","placeholder","_this10","toggleButton","toggleWrapper","getPlaceholder","hide","disabled","disable","node","VIDEO_PLAYER_MAP","_this11","_ref2","ui","disableOverlayUI","_this12","onClick","onPlayed","onPaused","onVideoClick","onAutoplayRequested","togglePlaying","Components","Slides","getAt","root","splide","Extensions","Video","players","Slide","className","contains","update","mount"],"version":3,"file":"index.d82774bf.js.map"}